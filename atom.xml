<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X-Mallory</title>
  
  <subtitle>Goals determine what you are going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-05T12:20:23.217Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小小苏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>有飞机起飞的地方，那一定是中航大</title>
    <link href="http://yoursite.com/2018/11/05/%E6%9C%89%E9%A3%9E%E6%9C%BA%E8%B5%B7%E9%A3%9E%E7%9A%84%E5%9C%B0%E6%96%B9%EF%BC%8C%E9%82%A3%E6%98%AF%E4%B8%AD%E8%88%AA%E5%A4%A7/"/>
    <id>http://yoursite.com/2018/11/05/有飞机起飞的地方，那是中航大/</id>
    <published>2018-11-05T11:34:46.000Z</published>
    <updated>2018-11-05T12:20:23.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有飞机起飞的地方，那是中航大-的主场"><a href="#有飞机起飞的地方，那是中航大-的主场" class="headerlink" title="有飞机起飞的地方，那是中航大 的主场"></a><center>有飞机起飞的地方，那是中航大 的主场</center></h4><p><img src="/2018/11/05/有飞机起飞的地方，那是中航大/运动场.bmp" alt=" " title=" "><br><a id="more"></a><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/白樱花.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/水天.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/飞天路.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/海棠花.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/冰雪篮球场.bmp" alt=" " title="直到，有了进展..."><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/千禧湖.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/雪花飘落.bmp" alt=" " title=" "></p><p><img src="/2018/11/05/有飞机起飞的地方，那是中航大/明德馆.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/北教1.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/南教2.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/南教1.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/南教3.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/夕阳下.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/霞光.bmp" alt=" " title=" "></p><p><img src="/2018/11/05/有飞机起飞的地方，那是中航大/冰雪千禧湖.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/蓝.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/体育场外.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/夜晚杭大.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/夜晚钟楼.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/综合食堂.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/俯瞰.bmp" alt=" " title=" "></p><p><img src="/2018/11/05/有飞机起飞的地方，那是中航大/灯光.bmp" alt=" " title=" "></p><p><img src="/2018/11/05/有飞机起飞的地方，那是中航大/飞机象征.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/雪天.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/雪中石.bmp" alt=" " title=" "><br><img src="/2018/11/05/有飞机起飞的地方，那是中航大/全景.bmp" alt=" " title=" "></p><p><img src="/2018/11/05/有飞机起飞的地方，那是中航大/雪天全景.bmp" alt=" " title=" "><br>转载自：[WeiQiImage]</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;有飞机起飞的地方，那是中航大-的主场&quot;&gt;&lt;a href=&quot;#有飞机起飞的地方，那是中航大-的主场&quot; class=&quot;headerlink&quot; title=&quot;有飞机起飞的地方，那是中航大 的主场&quot;&gt;&lt;/a&gt;&lt;center&gt;有飞机起飞的地方，那是中航大 的主场&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/11/05/有飞机起飞的地方，那是中航大/运动场.bmp&quot; alt=&quot; &quot; title=&quot; &quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="图集" scheme="http://yoursite.com/categories/%E5%9B%BE%E9%9B%86/"/>
    
    
      <category term="中航大" scheme="http://yoursite.com/tags/%E4%B8%AD%E8%88%AA%E5%A4%A7/"/>
    
      <category term="图集" scheme="http://yoursite.com/tags/%E5%9B%BE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>学术情侣Alice和Bob-附</title>
    <link href="http://yoursite.com/2018/09/05/%E5%AD%A6%E6%9C%AF%E6%83%85%E4%BE%A3Alice%E5%92%8CBob-%E9%99%84/"/>
    <id>http://yoursite.com/2018/09/05/学术情侣Alice和Bob-附/</id>
    <published>2018-09-05T07:19:54.000Z</published>
    <updated>2018-09-05T07:57:21.729Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Alice和Bob的漫画故事"><a href="#Alice和Bob的漫画故事" class="headerlink" title="Alice和Bob的漫画故事"></a><center>Alice和Bob的漫画故事</center></h4><p><img src="/2018/09/05/学术情侣Alice和Bob-附/1.PNG" alt="第一次约会" title="第一次约会..."><br><a id="more"></a><br><img src="/2018/09/05/学术情侣Alice和Bob-附/2.PNG" alt="情书" title="加密的一条消息..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/3.PNG" alt="猜不到" title="这是为你留的秘密..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/4.PNG" alt="数年后" title="相爱的几年..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/5.PNG" alt="为什么不告诉我" title="为什么不告诉我..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/6.PNG" alt="努力破解" title="每个夜晚，Alice都在努力破解..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/7.PNG" alt="进展" title="直到，有了进展..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/8.PNG" alt="爱的自信" title="Bob确信Alice一定可以的..."><br><img src="/2018/09/05/学术情侣Alice和Bob-附/9.PNG" alt="will you marry me" title="他一定是故意的..."></p><p>转载：<a href="https://abstrusegoose.com/113" target="_blank" rel="noopener">https://abstrusegoose.com/113</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Alice和Bob的漫画故事&quot;&gt;&lt;a href=&quot;#Alice和Bob的漫画故事&quot; class=&quot;headerlink&quot; title=&quot;Alice和Bob的漫画故事&quot;&gt;&lt;/a&gt;&lt;center&gt;Alice和Bob的漫画故事&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/05/学术情侣Alice和Bob-附/1.PNG&quot; alt=&quot;第一次约会&quot; title=&quot;第一次约会...&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="有趣的故事" scheme="http://yoursite.com/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>学术情侣Alice和Bob的故事</title>
    <link href="http://yoursite.com/2018/09/05/%E5%AD%A6%E6%9C%AF%E6%83%85%E4%BE%A3Alice%E5%92%8CBob%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/09/05/学术情侣Alice和Bob的故事/</id>
    <published>2018-09-05T06:43:06.000Z</published>
    <updated>2018-09-05T07:13:12.123Z</updated>
    
    <content type="html"><![CDATA[<h4 id="学术情侣Alice和Bob"><a href="#学术情侣Alice和Bob" class="headerlink" title="学术情侣Alice和Bob"></a><center>学术情侣Alice和Bob</center></h4><p><img src="/2018/09/05/学术情侣Alice和Bob的故事/Alice和Bob1.png" alt="情侣跑丢了" title="幻想中的Alice和Bob"></p><p>很多学术领域会用 Alice 和 Bob 做主人公，其中最经典最被人熟知的还是要数计算机安全，特别是密码学。</p><hr><a id="more"></a><h2 id="形影不离的学术情侣"><a href="#形影不离的学术情侣" class="headerlink" title="形影不离的学术情侣"></a>形影不离的学术情侣</h2><p>影视作品里出现过的情侣叫荧屏情侣，那么 Alice 和 Bob 就应该称作学术情侣了。很多学术领域会用 Alice 和 Bob 做主人公，其中最经典最被人熟知的还是要数计算机安全，特别是密码学。如果没有 Alice 和 Bob，在讲解密码协议的时候，文字描述大约会变成<a href="http://www.catb.org/jargon/html/A/Alice-and-Bob.html" target="_blank" rel="noopener">这样</a>：</p><blockquote><p>A 与某个声称自己是 B 的人通信。为了确保无误，A 必须先看看 B 是否知道密码 K。因此 A 向 B 发送了一段随机的 X，B 用 K 将 X 加密后得到 Y 并将 Y 回传给 A。</p></blockquote><p>在这样的一段话里，协议双方看上去像一段随机码一样冰冷单薄。而引入 Alice 和 Bob 代替 A 和 B，协议双方一下被赋予了人格，变得立体起来，读起来很容易有画面感，通信过程也随之变得更有剧情，更易理解。正因为如此，Alice 和 Bob 成为了学术讨论中频繁现身的一对好伙伴，课堂上、教科书里、论文中…在他们的帮助下，一批又一批学生理解了新的知识，一个又一个新思路得到传播，有人甚至在<a href="http://www.anagram.com/jcrap/Volume_3/caesar.pdf" target="_blank" rel="noopener">论文中</a>向 Alice 和 Bob 致谢。</p><h2 id="Alice-和-Bob-的诞生"><a href="#Alice-和-Bob-的诞生" class="headerlink" title="Alice 和 Bob 的诞生"></a>Alice 和 Bob 的诞生</h2><p>其实 Alice 和 Bob 的诞生远没有我预想的那么久远，算起来他们也就比我大十岁，是七五后。还记得 RSA 算法是如何提出的吗，经历了一番探究，某夜突然灵机一动的 RSA 之 R，Ron Rivest，彻夜写了那篇著名的论文阐述 RSA 算法的思想，而我们的 Alice 和 Bob 首次登台就是在那里。Rivest 不仅是 RSA 之父，也是 Alice 和 Bob 之父。就像他们没有料到 RSA 算法会得到如此广泛的应用一样，他也完全没有料到 Alice 和 Bob 成为了行业惯例，知名度甚至超过了自己。</p><p><img src="/2018/09/05/学术情侣Alice和Bob的故事/首登场.PNG" alt="首次登场" title="Alice和Bob的首次登场"></p><p>在一次采访中，Rivest 回忆起当初创造 Alice 和 Bob的情景。Alice 和 Bob 的诞生的确是为了避免在描述中使用 A 和 B，又因为他们分别以 A、B 开头，所以在算式中，仍然可以简洁地用 EA、EB 这样的形式区分。而创建一男一女两个角色，并不是为了给读者什么编罗曼史的机会（事实上无法避免地，很多人都这么做了），而是为了在描述时，可以方便地用她（she）和他（he）来指代而不至于混淆。至于为什么会是 Alice 和 Bob 这两个名字跳了出来，Rivest 自己猜测可能因为自己比较痴迷《爱丽丝梦游仙境》。</p><h2 id="Alice、Bob-和他们的朋友们"><a href="#Alice、Bob-和他们的朋友们" class="headerlink" title="Alice、Bob 和他们的朋友们"></a>Alice、Bob 和他们的朋友们</h2><p>RSA 算法的论文发表后，掀起了用 Alice 和 Bob 进行讲解的热潮。在后续发表和出版的文字中，人们陆续开始学着用 Alice 和 Bob 代替 A 和 B，其中最为著名的便是 Bruce Schneier 的《应用密码学》。Schneier 显然非常推崇这种作法，以至于在书中，即便是讲述 RSA 算法诞生前的各种协议和密码算法，他也用到了 Alice 和 Bob。由于有些协议情况复杂，Alice 和 Bob 两个人已经不能满足剧情，Schneier 在书的最开始给出了一个长长的演员表，除了发起和响应的 Alice 和 Bob，还有第三、四方 Carol 和 Dave，以及臭名昭著的窃听者 Eve，更为恶劣的主动攻击者 Mallory 等等。</p><p><img src="/2018/09/05/学术情侣Alice和Bob的故事/剧中人.PNG" alt="Alice的朋友们"></p><p>一个有趣的细节是，在《Secret History: The Story of Cryptology》一书中提到了一个变动，主动攻击者的名字从第一版的 Mallet 改成了第二版的 Mallory。尽管如此，Mallet 这个名字还是记录在密码学历史中，书中说，还有一个美国密码协会（American Cryptogram Association）的成员由此受启发，以 Mallet 做笔名。</p><h2 id="纠缠不清的一对冤家"><a href="#纠缠不清的一对冤家" class="headerlink" title="纠缠不清的一对冤家"></a>纠缠不清的一对冤家</h2><p>慢慢地 Alice 和 Bob 的形象丰富起来，关系也就变得复杂起来，变成了一对纠缠不清的冤家。两个人之间并没有看上去那么亲密，双方都不能信任对方，交流充满了猜疑和防范。然而两人却又是那么的密不可分，几乎永远成双成对出现，不管发生了什么，Alice 还总是想方设法地向 Bob 发送消息，Bob 则总是小心翼翼地接受它。Schneier 总结说，Alice 和 Bob 共享过秘密，尝试过恋爱、结婚，甚至离婚。任何一件需要安全进行的事，Alice 和 Bob 都一定曾在某篇密码学文章中做过。</p><p>密码学家 John Gordon 在他著名的<a href="https://urbigenous.net/library/alicebob.html" target="_blank" rel="noopener">餐后演说</a>中，形象地描述出这其中的纠结：</p><blockquote><p>多数人处于 Alice 的境地时会选择放弃，但 Alice 没有。她有着惊人的勇气。面对各种诡异的情况，充满噪声的电话线、税务机关和秘密警察的窃听，Alice 还是乐意去尝试和一个她并不信任、也听不清、还极有可能被别人冒充的人通信，来进行退税欺诈甚至策划政变，同时还要尽可能地减少电话费。   </p></blockquote><blockquote><p>而编码学家则是一群认为 Alice 没疯的人。</p></blockquote><h2 id="结局？"><a href="#结局？" class="headerlink" title="结局？"></a>结局？</h2><p>这是1984年的演讲，Gordon已经将Alice和Bob这对诞生不到十年的名字称作“longstanding tradition”了。不知道应该说是不出所料还是出人意料，这段通俗非正式的演讲一下走红。特别是文中八卦 Alice 和 Bob 的部分，更是被四处摘录。Gordon自嘲地说，现在没人知道他在密码学上的成就（强素数概念的提出），提起他都是说“那个八卦 Alice 和 Bob 的家伙”。他几次尝试把演讲稿从网页上撤下来，但都在读者的强烈抗议下重新放出。又是一个被Alice和Bob抢去风头的大师。其实这篇演讲相当有趣，除了Alice和Bob的问题，还用非常通俗的语言解释了编码学及其各个分支的基本概念，有兴趣可以进一步阅读。</p><p>Alice 和 Bob 最终会如何发展呢？他们会不会退休，会不会被新人代替？   </p><p>曾有印度学者提出用印度神话故事中的 Sita 和 Rama 代替 Alice 和 Bob（via），Sita 正好简写为 S，也就是 Sender，Rama 则代表 Receiver，同时这些人物所在的神话故事情节也正好是 Sita 要给 Rama 发送消息。这种思路类似于在交互式证明系统中，利用 Arthur（亚瑟王）和 Merlin（梅林）的历史角色来阐述和命名的方式。<br>但显然这种精心策划的解决方案不能撼动不经意兴起的惯例，我们的 Alice 和 Bob 还是会作为这个领域的传统传承下去，短期不会被其他名字代替。祝福他们会终成眷属，结束艰难的通信，幸福地生活在一起，直到永远。</p><p>参考：<a href="http://localhost-8080.com/2014/02/story-of-alice-and-bob/" target="_blank" rel="noopener">http://localhost-8080.com/2014/02/story-of-alice-and-bob/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;学术情侣Alice和Bob&quot;&gt;&lt;a href=&quot;#学术情侣Alice和Bob&quot; class=&quot;headerlink&quot; title=&quot;学术情侣Alice和Bob&quot;&gt;&lt;/a&gt;&lt;center&gt;学术情侣Alice和Bob&lt;/center&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/2018/09/05/学术情侣Alice和Bob的故事/Alice和Bob1.png&quot; alt=&quot;情侣跑丢了&quot; title=&quot;幻想中的Alice和Bob&quot;&gt;&lt;/p&gt;
&lt;p&gt;很多学术领域会用 Alice 和 Bob 做主人公，其中最经典最被人熟知的还是要数计算机安全，特别是密码学。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="有趣的故事" scheme="http://yoursite.com/tags/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>安全网络通信(JAVA-JSSE)</title>
    <link href="http://yoursite.com/2018/09/03/%C2%96%C2%96%E5%AE%89%E5%85%A8%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1-JAVA-JSSE/"/>
    <id>http://yoursite.com/2018/09/03/安全网络通信-JAVA-JSSE/</id>
    <published>2018-09-03T15:49:59.000Z</published>
    <updated>2018-09-05T07:10:12.221Z</updated>
    
    <content type="html"><![CDATA[<hr><p>JAVA安全套接字扩展（JSSE,Java Secure Socket Extension）基于SSL和TLS协议的Java网络应用程序提供了Java API及参考实现。JSSE支持数据加密、服务器端身份验证、数据完整性，以及可选的客户端身份认证，是信用JSSE,可以保证采用各种应用层协议（Http,telnet和Ftp等）的客户端程序与服务器程序安全的交换数据。<br>JSSE封装了底层复杂的安全通信细节，使得安全开发人员能方便的用它来开发安全的网络应用程序。</p><hr><a id="more"></a><h2 id="1、关于SSL"><a href="#1、关于SSL" class="headerlink" title="1、关于SSL"></a>1、关于SSL</h2><p>SSL(Server Socket Layer)是一种保证网络上连个节点进行安全通信的协议。IETF(Internet Engineering Task Force)对SSL做了标准化，制定了RFC2246规范，并将其成为TLS（Transport Layer Security)。从目前使用的技术上来讲，TLS1.0和SSL3.0之间的差别非常微小。<br>SSL采用加密技术来实现安全通信，保证通信数据的保密性和完整性，并且保证通信双方可以验证对方身份。  </p><h3 id="加密通信"><a href="#加密通信" class="headerlink" title="加密通信"></a>加密通信</h3><p><img src="/2018/09/03/安全网络通信-JAVA-JSSE/加密通信.png" alt="加密通信" title="加密通信"><br>处理对数据进行加密通信外，SSL还采用了身份认证机制，确保通信双方都可以验证对方的真实身份。个人可以通过身份证来来证明自己的身份，SSL通过安全安全证书来证明客户或者服务器的身份。当客户通过安全的连接和扶额u器通信时，服务器会首先向它出示它的安全证书，这个证书声明该服务器是安全的，而且的确是这个服务器。每个证书在全世界的范围内都是唯一的，其他服务器无法假冒原始服务器的身份。<br>安全证书采用公钥加密技术，安全证书机包含了用于加密数据的密钥，又包括了证明身份的数字签名。<br>获得安全证书的方式有两种，一种是从权威机构购买安全证书（安全证书由国际权威的证书机构 CA颁发），另一种是创建自签名的证书（SUN 公司提供的Key tool工具可以创建这样的证书）。</p><h3 id="SSL握手"><a href="#SSL握手" class="headerlink" title="SSL握手"></a>SSL握手</h3><p>客户在与服务器通信时，需要完成SSL握手，SSL握手主要完成以下任务：</p><ul><li>协商使用的加密套件（加密套件包括一组加密参数，这些参数指定了加密的算法和密钥的长度信息等）  </li><li>验证对方的身份（此操作可选）</li><li>确定使用的加密算法<br>SSL握手的流程如下：<br>（1）客户将自己的SSL版本号、加密参数、与会话有关的数据以及其他必要的信息发送给服务器。<br>（2）服务器将自己的SSL版本号、加密参数、与会话有关的数据以及其他必要的信息发送给客户端，同时还将自己的证书发送给客户，如果需要验证客户的身份，还会发出要求客户端提供证书的请求。<br>（3）客户端验证服务器的证书，如果验证失败，就提示不能建立SS连接，如果成功，则继续下面的步骤。<br>（4）客户端为本次会话生成预备主密钥（pre-master secret）,并用服务器的公钥加密之后发送给服务器。<br>（5）如果服务器要求验证客户端的身份，客户端还要对另外一些数签名后，连同自己的证书一起发送给服务器。<br>（6）如果服务器要求验证客户端的身份，则检查签署客户端证书的CA是否可信，如果在信任列表中，服务器用自己的私钥解密收到的预备主密钥，并用它通过某些算法生成本次会话的主密码（master-secret）。<br>（7）客户端和服务器均使用此主密码生成此次会话的会话密钥（对称密钥）。<br>（8）客户端通知服务器此后的通信都使用这个会话密钥进行加密，并通知服务器客户端已经完成此次SSL握手。<br>（9）服务器通知客户端此后的通信都使用这个会话密钥进行加密，并通知客户端服务器已经完成此次SSL握手。<br>（10）握手结束，会话建立。</li></ul><h2 id="2、JSSE简介"><a href="#2、JSSE简介" class="headerlink" title="2、JSSE简介"></a>2、JSSE简介</h2><p>JSSE封装了底层复杂的安全通信细节，使得安全开发人员能方便的用它来开发安全的网络应用程序，JDK1.4及以后版本中都自带了JSSE类库。</p><h4 id="JSSE主要包含一下四个包："><a href="#JSSE主要包含一下四个包：" class="headerlink" title="JSSE主要包含一下四个包："></a>JSSE主要包含一下四个包：</h4><ul><li>javax.net.ssl包：包括进行安全通信的类，比如SSLServerSocket和SSLSocket类。</li><li>javax.net包：包括安全套接字的工厂类，比如SSLServerSocketFactory和SSLSocketFactory类。 </li><li>java.security.cert包：包括处理安全证书的类，如X509Certificate类。</li><li>com.sun.net.ssl包：包括SUN公司提供的JSSE的实现类。<h4 id="JSSE具有以下重要特征："><a href="#JSSE具有以下重要特征：" class="headerlink" title="JSSE具有以下重要特征："></a>JSSE具有以下重要特征：</h4></li><li>纯粹用Java语言编写。</li><li>可以出口到大多数国家。 </li><li>提供了支持SSL2.0和SSL3.0的JSSE API,，并且提供了SSL 3.0 的JSSE实现。</li><li>提供了支持TLS1.0的JSSE API和JSSE实现。</li><li>提供了用于创建安全连接的类，如SSLSocket、SSLServerSocket和SSLEngine。</li><li>支持加密通信。 </li><li>支持客户端和服务器端的身份验证。 </li><li>支持SSL会话。 </li><li>支持一些常用的加密算法，比如RSA（加密长度2048位）、RC4（密钥长度128位）和DH（密钥长度1024位）。</li></ul><h4 id="JSSE-API的主要类框图"><a href="#JSSE-API的主要类框图" class="headerlink" title="JSSE API的主要类框图"></a>JSSE API的主要类框图</h4><p><img src="/2018/09/03/安全网络通信-JAVA-JSSE/主要类框图.png" alt="主要类框图" title="主要类框图"></p><p>JSSE中负责安全通信的最核心的类是SSLServerSocket类与SSLSocket类，它们分别是ServerSocket与Socket类的子类。<br>SSLSocket对象由SSLSocketFactory创建，此外，SSLServerSocket的accept()方法也会创建SSLSocket。<br>SSLServerSocket对象由SSLServerSocketFactory创建。<br>SSLSocketFactory、SSLServerSocketFactory以及SSLEngine对象都由SSLContext对象创建。<br>SSLEngine类用于支持非阻塞的安全通信。</p><h4 id="创建采用SSL协议的SSLSocket对象"><a href="#创建采用SSL协议的SSLSocket对象" class="headerlink" title="创建采用SSL协议的SSLSocket对象"></a>创建采用SSL协议的SSLSocket对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createSocket</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    factory=(SSLSocketFactory)SSLSocketFactory.getDefault();</span><br><span class="line">    socket=(SSLSocket)factory.createSocket(host,port);</span><br><span class="line">    String[] supported=socket.getSupportedCipherSuites();</span><br><span class="line">    socket.setEnabledCipherSuites(supported);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="KeyStore、KeyManager与TrustManager类"><a href="#KeyStore、KeyManager与TrustManager类" class="headerlink" title="KeyStore、KeyManager与TrustManager类"></a>KeyStore、KeyManager与TrustManager类</h4><p>在进行安全通信时，要求客户端与服务器端都支持SSL或TSL协议。<br>客户端与服务器端可能都需要设置用于证实自身身份的安全证书，还要设置信任对方的安全证书。<br>更常见的情况是，服务器只需要设置用于证实自身身份的安全证书，客户端只需要设置信任服务器的安全证书。<br>KeyStore类用于存放安全证书。以下程序代码创建了一个KeyStore对象，它从test.keys文件中加载安全证书。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String passphrase = <span class="string">"654321"</span>;</span><br><span class="line"><span class="comment">//JKS是SUN支持的KeyStore的类型</span></span><br><span class="line">KeyStore keyStore = KeyStore.getInstance(<span class="string">"JKS"</span>);  </span><br><span class="line"><span class="keyword">char</span>[] password = passphrase.toCharArray();</span><br><span class="line"><span class="comment">//password参数用于打开安全证书</span></span><br><span class="line">keyStore.load(<span class="keyword">new</span> FileInputStream(<span class="string">"test.keys"</span>), password);</span><br></pre></td></tr></table></figure></p><p>KeyManager接口的任务是选择用于证实自身身份的安全证书，把它发送给对方。KeyManagerFactory负责创建KeyManager对象，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">keyManagerFactory.init(keyStore, password);</span><br><span class="line">KeyManager[] keyManagers= keyManagerFactory.getKeyManagers();</span><br></pre></td></tr></table></figure></p><p>TrustManager接口的任务是决定是否信任对方的安全证书。<br>TruesManagerFactory负责创建TrustManager对象，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">trustManagerFactory.init(keyStore);</span><br><span class="line">TrustManager[] trustManagers= trustManagerFactory.getTrustManagers();</span><br></pre></td></tr></table></figure></p><h4 id="SSLContext类"><a href="#SSLContext类" class="headerlink" title="SSLContext类"></a>SSLContext类</h4><p>SSLContext类负责设置与安全通信有关的各种信息，比如使用的协议（SSL或者TLS），自身的安全证书以及对方的安全证书。SSLContext还负责构造SSLServerSocketFactory、SSLSocketFactory和SSLEngine对象。<br>以下程序代码创建并初始化了一个SSLContext对象，然后由它创建了一个SSLServerSocketFactory对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SSLContext sslCtx = SSLContext.getInstance(<span class="string">"TLS"</span>); <span class="comment">//采用TLS协议</span></span><br><span class="line">sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), <span class="keyword">null</span>);</span><br><span class="line">SSLServerSocketFactory ssf=sslCtx.getServerSocketFactory();</span><br></pre></td></tr></table></figure></p><p>SSLContext的init()方法定义如下:<br>init(KeyManager[] km, TrustManager[] tm, SecureRandom random)</p><ul><li>参数random用于设置安全随机数，如果为null，则采用默认的SecureRandom实现   </li><li>如果参数km为空，会创建一个默认的KeyMagager对象，以及与之相关联的KeyStore对象，KeyStore对象从系统属性javax.net.ssl.keyStore中获取安全证书，若不存在这个属性，那么KeyStore对象的内容为空.</li><li>如果参数tm为空，会创建一个默认的TrustManager对象，以及与之相关联的KeyStore对象，KeyStore对象按照如下步骤获取安全证书：<br>先尝试从系统属性javax.net.ssl.trustStore中获取安全证书<br>若上一步失败，就尝试把&lt;JDK目录&gt;/jre/security/jsscacerts文件作为安全证书文件<br>若上一步失败，就尝试把&lt;JDK目录&gt;/jre/security/cacerts文件作为安全证书文件<br>若上一步失败，则KeyStore对象内容为空   </li></ul><h4 id="SSLServerSocketFactory类负责创建SSLServerSocket对象："><a href="#SSLServerSocketFactory类负责创建SSLServerSocket对象：" class="headerlink" title="SSLServerSocketFactory类负责创建SSLServerSocket对象："></a>SSLServerSocketFactory类负责创建SSLServerSocket对象：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSLServerSocket serverSocket =</span><br><span class="line">(SSLServerSocket) sslServerSocketFactory.createServerSocket(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><p>SSLServerSocketFactory对象有两种创建方法：<br>调用SSLContext类的getServerSocketFactory()方法。<br>调用SSLServerSocketFactory类的静态getDefault()方法。<br>SSLServerSocketFactory类的静态方法getDefault()返回一个默认的SSLServerSocketFactory对象，他与一个默认的SSLcontext对象关联，getDefault()方法的实现按照如下方法初始化这个默认的SSLContext对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslContext.init(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></p><h4 id="SSLSocketFactory类负责创建SSLSocket对象"><a href="#SSLSocketFactory类负责创建SSLSocket对象" class="headerlink" title="SSLSocketFactory类负责创建SSLSocket对象"></a>SSLSocketFactory类负责创建SSLSocket对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslContext.init(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p>SSLSocketFactory对象有两种创建方法：<br>调用SSLContext类的getSocketFactory()方法。<br>调用SSLSocketFactory类的静态getDefault()方法<br>SSLSocketFactory类的静态方法getDefault()返回一个默认的SSLSocketFactory对象，他与一个n默认的SSLcontext对象关联，getDefault()方法的实现按照如下方法初始化这个默认的SSLContext对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslContext.init(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure></p><h4 id="SSLSocket类"><a href="#SSLSocket类" class="headerlink" title="SSLSocket类"></a>SSLSocket类</h4><p>SSLSocket类是Socket类的子类，因此两者的用法有许多相似之处。<br>SSLSocket类还具有与安全通信有关的方法:<br>(1)设置加密套件<br><em>SSLSocket类的getSupportedCipherSuites()方法返回一个字符串数组，它包含当前SSLSocket对象所支持的加密套件组。</em>SSLSocket类的setEnabledCipherSuites(String[] suites)方法设置当前SSLSocket对象的可使用的加密套件组。<br>可使用的加密套件组应该是所支持的加密套件组的子集。<br>*SSLSocket类的getEnabledCipherSuites()方法返回一个字符串数据，包含当前SSLSocket对象的可使用的加密套件组。<br>例如以下代码仅仅启用了具有高加密强度的加密套件，这可以提高该通信端的安全性，禁止那些不支持强加密的通信端连接当前通信端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] strongSuites=&#123;<span class="string">"SSL_DES_DSS_WITH_3DES_EDE_CBC_SHA"</span>,</span><br><span class="line"><span class="string">"SSL_RSA_WITH_RC4_128_MD5"</span>,</span><br><span class="line"><span class="string">"SSL_RSA_WITH_RC4_128_SHA"</span>,</span><br><span class="line"><span class="string">"SSL_RSA_WITH_3DES_EDE_CBC_SHA"</span>&#125;;</span><br><span class="line">sslSocket. setEnabledCipherSuites(strongSuites) ;</span><br></pre></td></tr></table></figure></p><p>(2)处理握手结束事件<br>SSL握手需要花很长的时间，当SSL握手完成，会发出一个HandshakeCompletedEvent事件，该事件由HandshakeCompletedListener负责监听。<br>SSLSocket类的addHandshakeCompletedListener()方法负责注册HandshakeCompletedListener监听器。<br>HandshakeCompletedEvent类提供了获取与握手事件相关的信息的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SSLSession <span class="title">getSession</span><span class="params">()</span>  <span class="comment">//获得会话</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCipherSuite</span><span class="params">()</span>   <span class="comment">//获得实际使用的加密套件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SSLSocket <span class="title">getSocket</span><span class="params">()</span>   <span class="comment">//获得发出该事件的套接字</span></span></span><br></pre></td></tr></table></figure></p><p>HandshakeCompletedListener接口的以下方法负责处理握手结束事件<br>public void handshakeCompleted(HandshakeCompletedEvent event)<br>(3)管理SSL会话<br>SSLSession接口表示SSL会话，它具有以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getId()  <span class="comment">//获得会话ID。每个会话都有惟一的ID</span></span><br><span class="line"><span class="function">String <span class="title">getCipherSuite</span><span class="params">()</span>  <span class="comment">//获得实际使用的加密套件</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCreationTime</span><span class="params">()</span>  <span class="comment">//获得创建会话的时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastAccessedTime</span><span class="params">()</span>  <span class="comment">//获得最近一次访问会话的时间。访问会话是指程序创建一个使用</span></span></span><br><span class="line"><span class="function">该会话的SSLSocket。</span></span><br><span class="line"><span class="function">String <span class="title">getPeerHost</span><span class="params">()</span>  <span class="comment">//获得通信对方的主机</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getPeerPort</span><span class="params">()</span>  <span class="comment">//获得通信对方的端口</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span>  <span class="comment">//使会话失效</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span>  <span class="comment">//判断会话是否有效</span></span></span><br></pre></td></tr></table></figure></p><p>SSLSocket的getSession()方法返回SSLSocket所属的会话。<br>SSLSocket的setEnableSessionCreation(boolean flag)方法决定SSLSocket是否允许创建新的会话。flag参数的默认值为true。<br>SSLSocket的startHandshake()方法显式的执行一次SSL握手。<br>由于多数情况下客户端无需向服务器证实自己的身份，因此当一个通信端无需向对方证实自己身份，就称它处于客户模式，否则称它处于服务器模式。<br>SSLSocket的setUseClientMode(boolean mode)方法用来设置客户模式或者服务器模式。<br>如果mode参数为true，就表示客户模式，即无需向对方证实自己的身份；<br>如果mode参数为false，就表示服务器模式，即需要向对方证实自己的身份。<br>当SSLSocket处于服务器模式，还可以通过以下方法来决定是否要求对方提供身份认证：<br>setWantClientAuth(boolean want)：当want参数为true，表示希望对方提供身份认证。如果对方未出示安全证书，连接不会中断，通信继续进行。<br>setNeedClientAuth(boolean need)：当need参数为true，表示要求对方必须提供身份认证。如果对方未出示安全证书，连接中断，通信无法继续。</p><h4 id="SSLServerSocket"><a href="#SSLServerSocket" class="headerlink" title="SSLServerSocket"></a>SSLServerSocket</h4><p>SSLServerSocket类是ServerSocket类的子类，因此两者的用法有许多相似之处。<br>此外，SSLServerSocket类还具有与安全通信有关的方法。这些方法与SSLSocket类中的同名方法具有相同的作用。<br>(1)设置加密套件的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] getSupportedCipherSuites()：返回一个字符串数组，它包含当前SSLServerSocket对象所支持的加密套件组。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnabledCipherSuites</span><span class="params">(String[] suites)</span>：设置当前SSLServerSocket对象可使用的加密套件组。</span></span><br><span class="line"><span class="function">String[] <span class="title">getEnabledCipherSuites</span><span class="params">()</span>：返回一个字符串数组，它包含当前SSLServerSocket对象可使用的加密套件组。</span></span><br></pre></td></tr></table></figure></p><p>(2)管理SSL会话的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEnableSessionCreation</span><span class="params">(<span class="keyword">boolean</span> flag)</span>：决定由当前SSLServerSocket对象创建的SSLSocket对象是否允许创建新的会话。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getEnableSessionCreation</span><span class="params">()</span>：判断由当前SSLServerSocket对象创建的SSLSocket对象是否允许创建新的会话。</span></span><br></pre></td></tr></table></figure></p><p>(3)设置客户端模式的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setUseClientMode</span><span class="params">(<span class="keyword">boolean</span> mode)</span>：当mode参数为<span class="keyword">true</span>，表示客户端模式。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWantClientAuth</span><span class="params">(<span class="keyword">boolean</span> want)</span>：当want参数为<span class="keyword">true</span>，表示希望对方提供身份认证。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNeedClientAuth</span><span class="params">(<span class="keyword">boolean</span> need)</span>：当need参数为<span class="keyword">true</span>，表示要求对方必须提供身份认证。</span></span><br></pre></td></tr></table></figure></p><h4 id="SSLEngine类"><a href="#SSLEngine类" class="headerlink" title="SSLEngine类"></a>SSLEngine类</h4><p>SSLEngine类与SocketChannel类联合使用，就能实现非阻塞的安全通信。<br>SSLEngine类封装了与安全通信有关的细节，把应用程序发送的应用数据打包为网络数据，打包就是指对应用数据进行加密，加入SSL握手数据，把它变为网络数据。<br>SSLEngine类还能把接收到的网络数据展开为应用数据，展开就是指对网络数据解密。<br>SSLEngine类的wrap()方法负责打包应用数据，unwrap()方法负责展开网络数据。</p><p><img src="/2018/09/03/安全网络通信-JAVA-JSSE/SSLEngine.png" alt="SSLEnging" title="SSLEning"></p><h2 id="创建基于SSL的安全服务器和安全客户"><a href="#创建基于SSL的安全服务器和安全客户" class="headerlink" title="创建基于SSL的安全服务器和安全客户"></a>创建基于SSL的安全服务器和安全客户</h2><p>比如：<br>创建一个基于SSL的安全服务器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.KeyManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLServerSocket;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLServerSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port =<span class="number">8000</span>;</span><br><span class="line"><span class="keyword">private</span> SSLServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">SSLContext context=creatSSLContext();</span><br><span class="line">SSLServerSocketFactory factory=context.getServerSocketFactory();</span><br><span class="line">serverSocket=(SSLServerSocket) factory.createServerSocket(port);</span><br><span class="line">System.out.println(<span class="string">"服务器启动！"</span>);</span><br><span class="line"></span><br><span class="line">String []supported=serverSocket.getSupportedCipherSuites();</span><br><span class="line">serverSocket.setEnabledCipherSuites(supported);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SSLContext <span class="title">creatSSLContext</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    String keyStoreFile=<span class="string">"test.keystore"</span>;</span><br><span class="line">    String password=<span class="string">"123456"</span>;</span><br><span class="line">    KeyStore ks=KeyStore.getInstance(<span class="string">"JKS"</span>);</span><br><span class="line">    <span class="keyword">char</span>[]psw=password.toCharArray();</span><br><span class="line">    ks.load(<span class="keyword">new</span> FileInputStream(keyStoreFile),psw);</span><br><span class="line">    KeyManagerFactory kmf=KeyManagerFactory.getInstance(<span class="string">"SunX509"</span>);</span><br><span class="line">    kmf.init(ks,psw);</span><br><span class="line">    </span><br><span class="line">    SSLContext sslContext=SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">    sslContext.init(kmf.getKeyManagers(), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sslContext;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"echo:"</span>+msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PrintWriter <span class="title">getWriter</span><span class="params">(Socket socket)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">OutputStream socketOutputStream=socket.getOutputStream();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PrintWriter(socketOutputStream,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BufferedReader <span class="title">getReader</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">InputStream socketIn=socket.getInputStream();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socketIn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">Socket socket=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">socket=serverSocket.accept();</span><br><span class="line">System.out.println(<span class="string">"新连接："</span>+socket.getInetAddress()+<span class="string">":"</span>+socket.getPort());</span><br><span class="line"></span><br><span class="line">BufferedReader br=getReader(socket);</span><br><span class="line">PrintWriter pw=getWriter(socket);</span><br><span class="line"></span><br><span class="line">String msg=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((msg=br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">pw.println(echo(msg));</span><br><span class="line"><span class="keyword">if</span>(msg.equals(<span class="string">"bye"</span>))&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(socket!=<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">new</span> EchoServer().service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的，创建一个基于SSL的安全客户<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocket;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String host=<span class="string">"localhost"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port=<span class="number">8000</span>;</span><br><span class="line"><span class="keyword">private</span> SSLSocket socket;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">()</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">SSLSocketFactory factory=(SSLSocketFactory) SSLSocketFactory.getDefault();</span><br><span class="line">socket=(SSLSocket) factory.createSocket(host,port);</span><br><span class="line"></span><br><span class="line">String[] supported=socket.getSupportedCipherSuites();</span><br><span class="line">socket.setEnabledCipherSuites(supported);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">new</span> EchoClient().talk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> PrintWriter <span class="title">getWriter</span><span class="params">(Socket socket)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">OutputStream socketOutputStream=socket.getOutputStream();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PrintWriter(socketOutputStream,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BufferedReader <span class="title">getReader</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">InputStream socketIn=socket.getInputStream();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socketIn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">BufferedReader bReader=getReader(socket);</span><br><span class="line">PrintWriter pWriter=getWriter(socket);</span><br><span class="line">BufferedReader localReader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String msg=<span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">while</span>((msg=localReader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line"> </span><br><span class="line"> pWriter.println(msg);</span><br><span class="line"> System.out.println(bReader.readLine());</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(msg.equals(<span class="string">"bye"</span>))&#123;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ul><li>JAVA安全套接字扩展（JSSE,Java Secure Socket Extension）基于SSL和TLS协议的Java网络应用程序提供了Java API及参考实现。JSSE支持数据加密、服务器端身份验证、数据完整性，以及可选的客户端身份认证，是信用JSSE,可以保证采用各种应用层协议（Http,telnet和Ftp等）的客户端程序与服务器程序安全的交换数据。   </li><li>JSSE封装了底层复杂的安全通信细节，使得安全开发人员能方便的用它来开发安全的网络应用程序。</li><li>JSSE中负责安全通信的最核心的类是SSLServerSocket类与SSLSocket类，它们分别是ServerSocket与Socket类的子类。</li><li>SSLSocket对象由SSLSocketFactory创建，此外，SSLServerSocket的accept()方法也会创建SSLSocket。</li><li>SSLServerSocket对象由SSLServerSocketFactory创建。</li><li>SSLSocketFactory、SSLServerSocketFactory以及SSLEngine对象都由SSLContext对象创建。</li><li>SSLEngine类用于支持非阻塞的安全通信。</li><li>SSLContext负责为SSLSocket和SSLSocketFactory设置安全参数，如使用的安全协议、安全证书、KeyManager、TrustManager和安全随机数等。</li></ul></blockquote><p>Mallory<br>2018年9月3日</p><hr><p>资料参考：<br>［1］孙卫琴 JAVA网络编程精解</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;JAVA安全套接字扩展（JSSE,Java Secure Socket Extension）基于SSL和TLS协议的Java网络应用程序提供了Java API及参考实现。JSSE支持数据加密、服务器端身份验证、数据完整性，以及可选的客户端身份认证，是信用JSSE,可以保证采用各种应用层协议（Http,telnet和Ftp等）的客户端程序与服务器程序安全的交换数据。&lt;br&gt;JSSE封装了底层复杂的安全通信细节，使得安全开发人员能方便的用它来开发安全的网络应用程序。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="JAVA" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="安全通信" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>从比特币开始学习区块链</title>
    <link href="http://yoursite.com/2018/06/03/%E4%BB%8E%E6%AF%94%E7%89%B9%E5%B8%81%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://yoursite.com/2018/06/03/从比特币开始学习区块链/</id>
    <published>2018-06-03T15:11:44.000Z</published>
    <updated>2018-09-05T06:55:02.520Z</updated>
    
    <content type="html"><![CDATA[<hr><p>区块链作为当前一个比较热门的新概念，一直不是很懂，但其中涉及到密码学安全的应用，遂网上查找资料，结合区块链技术在比特币上的应用，将自己的理解分享出来，也算是对自己的学习做一记录，如有错误，请多指点！</p><hr><a id="more"></a><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>在说区块链之前，首先来说一下比特币，不同的人可能对于比特币会有不同的理解，借用网上一位网友比较简单直白的解读：</p><blockquote><ul><li>比特币是一种基于分布式网络的数字货币。</li><li>比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。</li></ul></blockquote><p>在比特币的世界，没有属于个人的账户的概念，只有比特币钱包，所谓的比特币钱包，其实可以简单理解为一个<strong>公钥</strong>。由于电子计算机内的任何东西都是可以零成本复制的，所以就必须采用<strong>非对称密码技术</strong>解决这个问题。<br>简单点说，一个钱包的含义就是“任何人都可以放钱进去，但只有你自己可以拿钱出来”，你之所以比别人多一个拿钱出来花的权力，是因为你持有和钱包公钥对应的私钥！请务必记住，私钥就是你打开钱包花钱的钥匙，一旦被别人窃取，钱也就是别人的了，一旦丢失或者销毁，钱包里的钱也就相当于跟着销毁了，就好像现实中你把纸钞撕毁焚烧了一样。  </p><p>在比特币世界，所有能花费的钱被统一表示成UTXO(即Unspent Transaction Output)，该UTXO和一个钱包地址关联，你要想知道你还有多少钱可以花，你只能遍历你所拥有的钱包，然后把和该钱包关联的UTXO累加在一起，结果便是你的“账户余额。所有的这一切信息，全部分布式存储在已经达成全网共识的区块链里。<br>UTXO只有唯一的两个来源： </p><blockquote><ul><li>被人转给自己</li><li>自己挖矿所得</li></ul></blockquote><p>比特币交易就是从一个比特币钱包向另一个中转账，每笔交易都有数字签名来保证安全。一个交易一旦发生那么就是对所有人都公开的，当 Alice 想要给 Bob 转币的时候，就用私钥来签署一段信息，其中包括输入，数目和输出这三项前面已经提过的内容。这样，信息广播到比特币网络上，矿工就可以验证这次交易，把交易加入区块链中了,一旦加入区块链成功，也就表示此次交易成功，也表示此次的交易被加入到了分布式的账本中。  </p><p><img src="/2018/06/03/从比特币开始学习区块链/比特币交易.PNG" alt="比特币交易" title="比特币交易"></p><blockquote><ul><li>输入：这里面记录了最初 Alice  拥有的这些币是从哪个地址转给她的，假设她是从她的朋友 Eve 那里得到的币。</li><li>数目：这个就是 Alice 到底给 Bob 转了多少个比特币。</li><li>输出：Bob 的比特币地址。</li></ul></blockquote><h3 id="比特币的运行原理"><a href="#比特币的运行原理" class="headerlink" title="比特币的运行原理"></a>比特币的运行原理</h3><p>正如我们认识的银行那样，在银行系统的数据库里记录着跟我们身份id对应的财产，我们暂且把他叫做账本，如张三的卡10月1日转入1w, 余额10w。<br>比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。</p><h3 id="一个公共的分布式总帐—-区块链"><a href="#一个公共的分布式总帐—-区块链" class="headerlink" title="一个公共的分布式总帐—-区块链"></a>一个公共的分布式总帐—-区块链</h3><p>切入主题,区块链技术,我们首先考虑下面两种情况:<br>情况一:</p><blockquote><p> 想象有一个100台的分布式数据库集群，现在的情况是这100个节点实际上的拥有者是一个机构，并且所有节点处在该机构的内网当中，所以这个机构想让这100个数据库节点干嘛就干嘛，换句话说这100个节点之间是处于一个可信任的环境，并且受控于一个实体，这个实体具有绝对仲裁分配权。</p></blockquote><p>情况二:</p><blockquote><p>想象这100个节点分别归不同的人所有，且每个人的节点数据都是一样的，即完全冗余，并且所有的节点是处在广域网当中，换句话说就是这100个节点之间是不信任的，且不存在一个实体，它拥有绝对仲裁权。</p></blockquote><p>现在考虑第二种情况的话，采用什么样的算法（共识模型）能够提供一个可信任的环境，使得：</p><ul><li>每个节点交换数据过程不被篡改；交换历史记录不可被篡改；</li><li>每个节点的数据会同步到最新数据，且承认经过共识的最新数据；</li><li>基于少数服从多数的原则，整体节点维护的数据本身客观反映了交换历史。</li></ul><p><strong>区块链本质上就是要解决以上第二种情况的一种技术方案，更确切的说应该叫分布式的冗余的链式总帐本方案。</strong>   </p><p>要解决第二种情况的问题，那么区块链技术应该要具有这样的一些特性：</p><blockquote><ul><li>包含一个分布式数据库</li><li>区块链只对添加有效，对其他操作无效</li><li>分布式数据库作为区块链的物理载体，所有核心节点都应包含该条区块链数据的全副本</li><li>共识过程（consensus progress）是演化稳定的，所谓共识过程，指的是面对不同节点的矛盾数据，不会导致崩溃，关于矛盾数据，不同节点间最终应该能达成共识</li><li>记账节点要求拜占庭将军问题可解</li><li>基于非对称加密的公私钥验证</li></ul></blockquote><p>我们继续回到比特币上，我们继续看，结合前文说的比特币的运行原理，其中说到比特币系统需要维护一个由所有节点共同维护的账本，它是如何维护的呢，这就用到了区块链技术：  </p><h3 id="比特币区块链记账方法"><a href="#比特币区块链记账方法" class="headerlink" title="比特币区块链记账方法"></a>比特币区块链记账方法</h3><p>假设有一个账页序号为0的账页交易记录如下:</p><table><thead><tr><th style="text-align:center">账号</th><th style="text-align:center">入账</th><th style="text-align:center">出账</th><th style="text-align:center">余额</th><th style="text-align:center">备注说明</th></tr></thead><tbody><tr><td style="text-align:center">张三</td><td style="text-align:center">1600</td><td style="text-align:center"></td><td style="text-align:center">1600</td><td style="text-align:center">XXX转入</td></tr><tr><td style="text-align:center">李四</td><td style="text-align:center"></td><td style="text-align:center">600</td><td style="text-align:center">1200</td><td style="text-align:center">转给XXX</td></tr></tbody></table><p>记账时间为：2017-10-22 10:22:02</p><p>区块链记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：  </p><p><em>Hash(序号0、记账时间、交易记录) = 787635ACD</em></p><p>账页信息和Hash值组合在一起就构成了第一个区块。</p><p><strong>比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟</strong></p><p>在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即：</p><p><em>Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD</em>  </p><p>这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。<br>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。</p><h3 id="记账与挖矿"><a href="#记账与挖矿" class="headerlink" title="记账与挖矿"></a>记账与挖矿</h3><p>上面说到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”。</p><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，每个比特币是4万人民币以上），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解这个问题，规则如下：</p><ul><li>一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li><li>其他节点复制记账结果<br>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</li><li>收集广播中还没有被记录账本的原始交易信息</li><li>检查每个交易信息中付款地址有没有足够的余额</li><li>验证交易是否有正确的签名</li><li>把验证通过的交易信息进行打包记录</li><li>添加一个奖励交易：给自己的地址增加12.5比特币<br>如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。 </li></ul><h3 id="关于工作量证明"><a href="#关于工作量证明" class="headerlink" title="关于工作量证明"></a>关于工作量证明</h3><p>每次记账的时候会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。<br>如果仅仅是这样，显然每个人都可以很轻松的完成记账。<br>为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。</p><blockquote><p>Hash(上一个Hash值，交易记录集) = 456635BCD</p></blockquote><blockquote><p>Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD</p></blockquote><p>我们知道改变Hash的原始信息的任何一部分，Hash值也会随之不断的变化，因此在运算Hash时，不断的改变随机数的值，总可以找的一个随机数使的Hash的结果以若干个0开头，率先找到随机数的节点就获得此次记账的唯一记账权。  </p><p><img src="/2018/06/03/从比特币开始学习区块链/Hash.png" alt="挖矿" title="挖矿"></p><p> 在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。<br>如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。<br>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p><h5 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h5><p>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。<br>区块链中，可以将这里的叛徒看成是一台有故障不断向其他节点发出错误信息的计算机，或是一台计算机，为谋取暴利，做了一份假的账本，不断向其他节点发送。  </p><h5 id="公钥密码体制-public-key-cryptography"><a href="#公钥密码体制-public-key-cryptography" class="headerlink" title="公钥密码体制(public-key cryptography)"></a>公钥密码体制(public-key cryptography)</h5><p>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：<br>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。<br>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。<br>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>哈希函数在密码学中被用来做消息摘要，一个消息摘唯一对应一个消息或文本，并且这个消息摘要的长度通常是固定的，原始消息或文本中任何微小的改变都将导致消息摘要值的改变，通过消息摘要，可以验证消息的完整性。<br>哈希函数：Hash(原始信息) = 摘要信息<br>原始信息可以是任意的信息, hash之后会得到一个简短的摘要信息<br>哈希函数有几个特点:</p><ul><li>同样的原始信息用同一个哈希函数总能得到相同的摘要信息</li><li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li><li>从摘要信息无法逆向推算出原始信息<br>举例说明：<br>Hash(张三借给李四100万，利息1%，1年后还本息 …..) = AC4635D34DEF<br>账本上记录了AC4635D34DEF这样一条记录。<br>可以看出哈希函数有4个作用：<blockquote><ul><li>简化信息：很好理解，哈希后的信息变短了。</li><li>标识信息：可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。</li><li>隐匿信息：账本是AC4635D34DEF这样一条记录，原始信息被隐匿。</li><li>验证信息：假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证信息 </li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;区块链作为当前一个比较热门的新概念，一直不是很懂，但其中涉及到密码学安全的应用，遂网上查找资料，结合区块链技术在比特币上的应用，将自己的理解分享出来，也算是对自己的学习做一记录，如有错误，请多指点！&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="密码学" scheme="http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    
      <category term="比特币" scheme="http://yoursite.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>心有猛虎 细嗅蔷薇</title>
    <link href="http://yoursite.com/2018/05/10/%E5%BF%83%E6%9C%89%E7%8C%9B%E8%99%8E-%E7%BB%86%E5%97%85%E8%94%B7%E8%96%87/"/>
    <id>http://yoursite.com/2018/05/10/心有猛虎-细嗅蔷薇/</id>
    <published>2018-05-10T04:08:53.000Z</published>
    <updated>2018-05-10T13:05:41.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="In-me-the-tiger-sniffs-the-rose"><a href="#In-me-the-tiger-sniffs-the-rose" class="headerlink" title="In me the tiger sniffs the rose"></a><center>In me the tiger sniffs the rose</center></h2><p align="right">————心有猛虎 细嗅蔷薇</p><p><img src="/2018/05/10/心有猛虎-细嗅蔷薇/树叶.jpg" alt="In me the tiger sniffs the rose" title="细嗅蔷薇"></p><p>每个人的内心深处都穴居着一只猛虎，只是在虎穴之外仍有蔷薇丛生。<br><a id="more"></a></p><p>我将于茫茫人海中访我唯一灵魂之伴侣；<br>得之，我幸；不得，我命。  </p><p align="right">———  徐志摩 </p>   <p>笑，全世界便与你同声笑，哭，你便独自哭。<br>因为爱过，所以慈悲；因为懂得，所以宽容。</p><p align="right">———张爱玲</p>   <p>爱在左，情在右，<br>走在生命路的两旁，<br>随时撒种，随时开花。</p><p align="right">———冰心 </p>   <p>我行过许多地方的桥，<br>看过许多次数的云，<br>喝过许多种类的酒，<br>却只爱过一个正当最好年龄的人。</p><p align="right">———沈从文</p>  <p>撑着油纸伞，独自彷徨在悠长、<br>悠长又寂寥的雨巷我希望逢着一个，<br>丁香一样地结着愁<br>的姑娘 。</p><p align="right">———戴舒望</p>   <p>人生不过如此，且行且珍惜。<br>自己永远是自己的主角，<br>不要总在别人的戏剧里充当着配角。<br>人生在世，还不是有时笑笑人家，<br>有时给人家笑笑。</p><p align="right">———林语堂 </p>   <p>多年前踏上火车时，我还没有意识到，<br>从此我的故乡没有春夏，只有秋冬。<br>热闹是他们的，我什么也没有。</p><p align="right">———朱自清 </p>   <p>我知道你要来，所以我等。</p><p align="right">———沈从文 </p>   ]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;In-me-the-tiger-sniffs-the-rose&quot;&gt;&lt;a href=&quot;#In-me-the-tiger-sniffs-the-rose&quot; class=&quot;headerlink&quot; title=&quot;In me the tiger sniffs the rose&quot;&gt;&lt;/a&gt;&lt;center&gt;In me the tiger sniffs the rose&lt;/center&gt;&lt;/h2&gt;&lt;p align=&quot;right&quot;&gt;————心有猛虎 细嗅蔷薇&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/2018/05/10/心有猛虎-细嗅蔷薇/树叶.jpg&quot; alt=&quot;In me the tiger sniffs the rose&quot; title=&quot;细嗅蔷薇&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个人的内心深处都穴居着一只猛虎，只是在虎穴之外仍有蔷薇丛生。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="谈文识字" scheme="http://yoursite.com/categories/%E8%B0%88%E6%96%87%E8%AF%86%E5%AD%97/"/>
    
    
      <category term="诗词" scheme="http://yoursite.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="散文" scheme="http://yoursite.com/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>共勉</title>
    <link href="http://yoursite.com/2018/05/03/%E5%85%B1%E5%8B%89/"/>
    <id>http://yoursite.com/2018/05/03/共勉/</id>
    <published>2018-05-03T11:13:36.000Z</published>
    <updated>2018-05-04T10:47:55.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/03/共勉/风筝.jpg" alt="诗和远方" title="有诗也有远方"><br><a id="more"></a></p><h5 id="我不去想是否能够成功"><a href="#我不去想是否能够成功" class="headerlink" title="我不去想是否能够成功 "></a><center>我不去想是否能够成功 </center></h5><h5 id="既然选择了远方"><a href="#既然选择了远方" class="headerlink" title="既然选择了远方 "></a><center>既然选择了远方 </center></h5><h5 id="便只顾风雨兼程"><a href="#便只顾风雨兼程" class="headerlink" title="便只顾风雨兼程   "></a><center>便只顾风雨兼程   </center></h5><h5 id="我不去想能否赢得爱情"><a href="#我不去想能否赢得爱情" class="headerlink" title="我不去想能否赢得爱情 "></a><center>我不去想能否赢得爱情 </center></h5><h5 id="既然钟情于玫瑰"><a href="#既然钟情于玫瑰" class="headerlink" title="既然钟情于玫瑰 "></a><center>既然钟情于玫瑰 </center></h5><h5 id="就勇敢地吐露真诚"><a href="#就勇敢地吐露真诚" class="headerlink" title="就勇敢地吐露真诚   "></a><center>就勇敢地吐露真诚   </center></h5><h5 id="我不去想身后-会不会袭来寒风冷雨"><a href="#我不去想身后-会不会袭来寒风冷雨" class="headerlink" title="我不去想身后 会不会袭来寒风冷雨 "></a><center>我不去想身后 会不会袭来寒风冷雨 </center></h5><h5 id="既然目标是地平线"><a href="#既然目标是地平线" class="headerlink" title="既然目标是地平线 "></a><center>既然目标是地平线 </center></h5><h5 id="留给世界的只能是背影"><a href="#留给世界的只能是背影" class="headerlink" title="留给世界的只能是背影  "></a><center>留给世界的只能是背影  </center></h5><h5 id="我不去想未来是平坦还是泥泞"><a href="#我不去想未来是平坦还是泥泞" class="headerlink" title="我不去想未来是平坦还是泥泞  "></a><center>我不去想未来是平坦还是泥泞  </center></h5><h5 id="只要热爱生命"><a href="#只要热爱生命" class="headerlink" title="只要热爱生命 "></a><center>只要热爱生命 </center></h5><h5 id="一切，都在意料之中"><a href="#一切，都在意料之中" class="headerlink" title="一切，都在意料之中  "></a><center>一切，都在意料之中  </center></h5><p align="right"><br>–至今，我仍然记得这是高中班主任很喜欢的一首诗，共勉 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/03/共勉/风筝.jpg&quot; alt=&quot;诗和远方&quot; title=&quot;有诗也有远方&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="谈文识字" scheme="http://yoursite.com/categories/%E8%B0%88%E6%96%87%E8%AF%86%E5%AD%97/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="诗词" scheme="http://yoursite.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程之Volatile变量应用详解</title>
    <link href="http://yoursite.com/2017/11/13/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%8F%98%E9%87%8F%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/11/13/JAVA并发编程之Volatile变量应用详解/</id>
    <published>2017-11-13T11:21:18.000Z</published>
    <updated>2018-09-05T06:56:40.088Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="right">———关于多线程编程，实在有太多的惊喜在等着你去发现，一步一脚印</p><br><a id="more"></a><p></p><h3 id="一、-Volatile关键字概述"><a href="#一、-Volatile关键字概述" class="headerlink" title="一、 Volatile关键字概述"></a>一、 Volatile关键字概述</h3><p>首先明确一点，Volatile是JAVA（其他语言如C++也相似）中的一个关键字，一种书写于成员变量之前的修饰符，如static，public一样，他书写于某种类型的变量之前，表征定义的变量具有相关的特性。之所以说明这一点，是为了避免对标题“Volatile变量”的歧义理解，它不是一种具体的变量的类型，而是对某一种具体变量的修饰。如 volatile int a。明确这一点后，先大致说明一下这个volatile修饰具有怎样的含义：Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。为了深刻理解上面关于volatile的说明，接下来做具体的说明。</p><h3 id="二、-和volatile相关的几个基本概念"><a href="#二、-和volatile相关的几个基本概念" class="headerlink" title="二、 和volatile相关的几个基本概念"></a>二、 和volatile相关的几个基本概念</h3><p>为了更好的理解volatile，首先先说明几个相关的几个基本概念：</p><h4 id="（1）-内存模型（JAVA内存模型）"><a href="#（1）-内存模型（JAVA内存模型）" class="headerlink" title="（1）    内存模型（JAVA内存模型）"></a>（1）    内存模型（JAVA内存模型）</h4><p>我们知道计算机的cpu在执行指令的时候，是离不开往内存里读数据和写数据的，但是我们也知道往内存里读写数据的速度，相比于CPU执行指令的速度是要慢很多的，于是在CPU和内存之间就有了高速缓存Cache。也就是说为了避免读写内内存降低指令执行的速度和CPU的效率，当程序在运行时，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 </p><p><img src="/2017/11/13/JAVA并发编程之Volatile变量应用详解/内存模型.PNG" alt="内存模型" title="内存模型"></p><h4 id="（2）-可见性"><a href="#（2）-可见性" class="headerlink" title="（2）    可见性"></a>（2）    可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。假如上面的X具有可见性，也就不会具有上面的问题。  </p><h4 id="（3）-原子性"><a href="#（3）-原子性" class="headerlink" title="（3）    原子性"></a>（3）    原子性</h4><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><h4 id="（4）-有序性"><a href="#（4）-有序性" class="headerlink" title="（4）    有序性"></a>（4）    有序性</h4><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><h3 id="三、-细说Volatile"><a href="#三、-细说Volatile" class="headerlink" title="三、 细说Volatile"></a>三、 细说Volatile</h3><p>明白了上述的概念后，可以为volatile修饰重新下一个定义：Volatile 变量具有可见性特性，但是不具备原子特性 ，volatile禁止进行指令重排序。一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，也就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，而不是读取原来Cache中的值。 下面具体的来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>(实际上，上述的这种结构也是我们在编程的过程中常用到的一种结构），由一个状态标志值控制一段程序是否执行，当flag未用volatile修饰时，线程1中可能读到一个值为true的flag到自己的Cache中，每次执行循环判断时，都从Cache中读flag 的值进行判断，导致循环永远不会结束，即使线程2执行后将flag改为false,写回内存中，但是线程1不从内存读值，便始终读到的flag都是true，导致无法结束循环，但是如果flag用volatile修饰后，只要线程2修改了flag 的值，并重新写回内存后，线程1在执行时，cache中的flag值将是无效的，需要强制从内存中读值，也就能读到改变后的flag的值，循环也将能够退出。<br>    上述的定义中还值得注的一点是volatile不具有原子性，我们再来看另一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个由volatile修饰的变量由多个线程共享</span></span><br><span class="line">Public <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//做10次循环，每次循环创建一个线程，对x做100次自加运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个线程，对x做100次自加运算</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">        Thread.yield();</span><br><span class="line"><span class="comment">//显示x的值</span></span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终的运算结果是：<br><img src="/2017/11/13/JAVA并发编程之Volatile变量应用详解/输出结果.PNG" alt="结果" title=" "></p><p>实际上，每次运行的结果都可能不同，按照前面的分析，加了volatile修饰后即使是多个线程之间，每次对x的值的更改，其他的线程也会马上接收到，那10次循环，每次循环的一个线程对x执行100次自加运算，那结果应该为1000才对，那为什么每次执行的结果还不相同呢？因为volatile不具有原子性，其实此处的自增运算X++,不是一个原子操作，涉及到一次都读操作，和一次写操作，假设一个线程读完x的值，完成一次自加1后，还未执行写操作，就立马执行另一个线程，此线程执行读操作，从内存读值，由于之前的线程并未执行写操作，还未将增加的值写入内存，第二个线程自然也就只读到原来的值，他执行自增操作后，将值写入内存，线程1读操作已经完成，在执行写操作，再将自己自增完的值写入内存，实际上两个线程就只对x的值增加了1，这就和我们的设想有偏差了，也就导致了每次的结果是不确定的，这也就很好的说明了volatie不具有原子性。  </p><p> 这也提醒了我们在使用volatile修饰的变量时，虽然使得变量具有了可见性，但是并不具有原子性，也就是说volatile的安全使用是有限制的。如果同时需要保证可见性和原子性，那就需要使用synchronized关键字，关于synchronized关键字，这里不做多说，但是我们需要知道synchronized是一个内置锁的加锁机制，当一段临界区代码有了这个加锁机制之后，多个线程中某一时刻只允许一个线程在执行这段这段代码，那既然有了synchronized ，为什么还需要Volatile，网上有一个比较好的回答，volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种synchronized关键字更轻量级的同步机制。volatile 操作不会像锁一样造成阻塞，某些时刻，volatile变量同步机制的性能要高于synchronized，使用上也比使用相应的锁简单得多。</p><h3 id="四、正确使用-volatile-变量"><a href="#四、正确使用-volatile-变量" class="headerlink" title="四、正确使用 volatile 变量"></a>四、正确使用 volatile 变量</h3><h4 id="（1）状态标记量"><a href="#（1）状态标记量" class="headerlink" title="（1）状态标记量"></a>（1）状态标记量</h4><p>  也就是举的第一个代码的例子，将 volatile 变量作为状态标志布尔变量使用，用于指示发生了一个重要的一次性事件。<br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><h4 id="（2）独立观察"><a href="#（2）独立观察" class="headerlink" title="（2）独立观察"></a>（2）独立观察</h4><p>定期 “发布” 观察结果供程序内部使用，就是说假如一个线程一直在接收一个一直在改变的数据写到volatile变量中，另外一个线程隔一段时间将会读取这个volatile变量进行一些操作。</p><p>如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。<br>好像我自己当前能理解、用到的也就这两种，其实，我对上面两种情况的理解也就是多个线程对一个共享变量的操作是原子操作的情况下，可以使用volatile变量，这样不会引起线程同步安全问题的，但使得维护线程同步安全的代价降到很低。无需用到synchronized。</p><h3 id="五、-volatile的原理和实现机制"><a href="#五、-volatile的原理和实现机制" class="headerlink" title="五、 volatile的原理和实现机制"></a>五、 volatile的原理和实现机制</h3><p>通过网上查阅和书籍查阅，简单理解了volatile的原理和实现机制，这是网上对原理解析的一段话：<br>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。    —— <a href="" target="_blank">  《深入理解Java虚拟机》</a></p><p>lock前缀指令实际上会提供3个功能：  </p><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。  </li></ul><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>关于volatile变量，我自己通过各方面的资料查阅，理解也就差不多如上，总结来说，volatilei变量是一种比 synchronized关键字更轻量级的同步机制。volatile 操作不会像锁一样造成阻塞，volatile修饰的变量具有可见性，但是不具有原子性，volatile禁止进行指令重排序，严格遵循volatile的使用条件的话，某些情况下可以使用 volatile 代替 synchronized 来简化代码。</p><p>资料参考：<br>［1］海子.Java并发编程volatile关键字解析[J/OL]   <a href="http://www.importnew.com/18126.html" title="　" target="_blank" rel="noopener">http://www.importnew.com/18126.html</a><br>［2］周志明．深入理解Java虚拟机 [M]．第1版.机械工业出版社，2011年6月</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;———关于多线程编程，实在有太多的惊喜在等着你去发现，一步一脚印&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA　" scheme="http://yoursite.com/tags/JAVA/"/>
    
      <category term="多线程并发" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
