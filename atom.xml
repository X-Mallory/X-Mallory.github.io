<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X-Mallory</title>
  
  <subtitle>Goals determine what you are going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-10T04:45:06.239Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小小苏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>心有猛虎 细嗅蔷薇</title>
    <link href="http://yoursite.com/2018/05/10/%E5%BF%83%E6%9C%89%E7%8C%9B%E8%99%8E-%E7%BB%86%E5%97%85%E8%94%B7%E8%96%87/"/>
    <id>http://yoursite.com/2018/05/10/心有猛虎-细嗅蔷薇/</id>
    <published>2018-05-10T04:08:53.000Z</published>
    <updated>2018-05-10T04:45:06.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="In-me-the-tiger-sniffs-the-rose"><a href="#In-me-the-tiger-sniffs-the-rose" class="headerlink" title="In me the tiger sniffs the rose"></a><center>In me the tiger sniffs the rose</center></h2><p align="right">————心有猛虎 细嗅蔷薇</p><p><img src="/2018/05/10/心有猛虎-细嗅蔷薇/树叶.jpg" alt="In me the tiger sniffs the rose" title=" "></p><p>每个人的内心深处都穴居着一只猛虎，只是在虎穴之外仍有蔷薇丛生。<br><a id="more"></a></p><p>我将于茫茫人海中访我唯一灵魂之伴侣；<br>得之，我幸；不得，我命。  </p><p align="right">———  徐志摩 </p>   <p>笑，全世界便与你同声笑，哭，你便独自哭。<br>因为爱过，所以慈悲；因为懂得，所以宽容。</p><p align="right">———张爱玲</p>   <p>爱在左，情在右，<br>走在生命路的两旁，<br>随时撒种，随时开花。</p><p align="right">———冰心 </p>   <p>我行过许多地方的桥，<br>看过许多次数的云，<br>喝过许多种类的酒，<br>却只爱过一个正当最好年龄的人。</p><p align="right">———沈从文</p>  <p>撑着油纸伞，独自彷徨在悠长、<br>悠长又寂寥的雨巷我希望逢着一个，<br>丁香一样地结着愁<br>的姑娘 。</p><p align="right">———戴舒望</p>   <p>人生不过如此，且行且珍惜。<br>自己永远是自己的主角，<br>不要总在别人的戏剧里充当着配角。<br>人生在世，还不是有时笑笑人家，<br>有时给人家笑笑。</p><p align="right">———林语堂 </p>   <p>多年前踏上火车时，我还没有意识到，<br>从此我的故乡没有春夏，只有秋冬。<br>热闹是他们的，我什么也没有。</p><p align="right">———朱自清 </p>   <p>我知道你要来，所以我等。</p><p align="right">———沈从文 </p>   ]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;In-me-the-tiger-sniffs-the-rose&quot;&gt;&lt;a href=&quot;#In-me-the-tiger-sniffs-the-rose&quot; class=&quot;headerlink&quot; title=&quot;In me the tiger sniffs the rose&quot;&gt;&lt;/a&gt;&lt;center&gt;In me the tiger sniffs the rose&lt;/center&gt;&lt;/h2&gt;&lt;p align=&quot;right&quot;&gt;————心有猛虎 细嗅蔷薇&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/2018/05/10/心有猛虎-细嗅蔷薇/树叶.jpg&quot; alt=&quot;In me the tiger sniffs the rose&quot; title=&quot; &quot;&gt;&lt;/p&gt;
&lt;p&gt;每个人的内心深处都穴居着一只猛虎，只是在虎穴之外仍有蔷薇丛生。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="谈文识字" scheme="http://yoursite.com/categories/%E8%B0%88%E6%96%87%E8%AF%86%E5%AD%97/"/>
    
    
      <category term="诗词" scheme="http://yoursite.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="散文" scheme="http://yoursite.com/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>共勉</title>
    <link href="http://yoursite.com/2018/05/03/%E5%85%B1%E5%8B%89/"/>
    <id>http://yoursite.com/2018/05/03/共勉/</id>
    <published>2018-05-03T11:13:36.000Z</published>
    <updated>2018-05-04T10:47:55.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/03/共勉/风筝.jpg" alt="诗和远方" title="有诗也有远方"><br><a id="more"></a></p><h5 id="我不去想是否能够成功"><a href="#我不去想是否能够成功" class="headerlink" title="我不去想是否能够成功 "></a><center>我不去想是否能够成功 </center></h5><h5 id="既然选择了远方"><a href="#既然选择了远方" class="headerlink" title="既然选择了远方 "></a><center>既然选择了远方 </center></h5><h5 id="便只顾风雨兼程"><a href="#便只顾风雨兼程" class="headerlink" title="便只顾风雨兼程   "></a><center>便只顾风雨兼程   </center></h5><h5 id="我不去想能否赢得爱情"><a href="#我不去想能否赢得爱情" class="headerlink" title="我不去想能否赢得爱情 "></a><center>我不去想能否赢得爱情 </center></h5><h5 id="既然钟情于玫瑰"><a href="#既然钟情于玫瑰" class="headerlink" title="既然钟情于玫瑰 "></a><center>既然钟情于玫瑰 </center></h5><h5 id="就勇敢地吐露真诚"><a href="#就勇敢地吐露真诚" class="headerlink" title="就勇敢地吐露真诚   "></a><center>就勇敢地吐露真诚   </center></h5><h5 id="我不去想身后-会不会袭来寒风冷雨"><a href="#我不去想身后-会不会袭来寒风冷雨" class="headerlink" title="我不去想身后 会不会袭来寒风冷雨 "></a><center>我不去想身后 会不会袭来寒风冷雨 </center></h5><h5 id="既然目标是地平线"><a href="#既然目标是地平线" class="headerlink" title="既然目标是地平线 "></a><center>既然目标是地平线 </center></h5><h5 id="留给世界的只能是背影"><a href="#留给世界的只能是背影" class="headerlink" title="留给世界的只能是背影  "></a><center>留给世界的只能是背影  </center></h5><h5 id="我不去想未来是平坦还是泥泞"><a href="#我不去想未来是平坦还是泥泞" class="headerlink" title="我不去想未来是平坦还是泥泞  "></a><center>我不去想未来是平坦还是泥泞  </center></h5><h5 id="只要热爱生命"><a href="#只要热爱生命" class="headerlink" title="只要热爱生命 "></a><center>只要热爱生命 </center></h5><h5 id="一切，都在意料之中"><a href="#一切，都在意料之中" class="headerlink" title="一切，都在意料之中  "></a><center>一切，都在意料之中  </center></h5><p align="right"><br>–至今，我仍然记得这是高中班主任很喜欢的一首诗，共勉 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/03/共勉/风筝.jpg&quot; alt=&quot;诗和远方&quot; title=&quot;有诗也有远方&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="谈文识字" scheme="http://yoursite.com/categories/%E8%B0%88%E6%96%87%E8%AF%86%E5%AD%97/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="诗词" scheme="http://yoursite.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程之Volatile变量应用详解</title>
    <link href="http://yoursite.com/2017/11/13/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%8F%98%E9%87%8F%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/11/13/JAVA并发编程之Volatile变量应用详解/</id>
    <published>2017-11-13T11:21:18.000Z</published>
    <updated>2018-05-04T12:09:15.260Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="right">———关于多线程编程，实在有太多的惊喜在等着你去发现，一步一脚印</p><br><a id="more"></a><p></p><h3 id="一、-Volatile关键字概述"><a href="#一、-Volatile关键字概述" class="headerlink" title="一、 Volatile关键字概述"></a>一、 Volatile关键字概述</h3><p>首先明确一点，Volatile是JAVA（其他语言如C++也相似）中的一个关键字，一种书写于成员变量之前的修饰符，如static，public一样，他书写于某种类型的变量之前，表征定义的变量具有相关的特性。之所以说明这一点，是为了避免对标题“Volatile变量”的歧义理解，它不是一种具体的变量的类型，而是对某一种具体变量的修饰。如 volatile int a。明确这一点后，先大致说明一下这个volatile修饰具有怎样的含义：Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。为了深刻理解上面关于volatile的说明，接下来做具体的说明。</p><h3 id="二、-和volatile相关的几个基本概念"><a href="#二、-和volatile相关的几个基本概念" class="headerlink" title="二、 和volatile相关的几个基本概念"></a>二、 和volatile相关的几个基本概念</h3><p>为了更好的理解volatile，首先先说明几个相关的几个基本概念：</p><h4 id="（1）-内存模型（JAVA内存模型）"><a href="#（1）-内存模型（JAVA内存模型）" class="headerlink" title="（1）    内存模型（JAVA内存模型）"></a>（1）    内存模型（JAVA内存模型）</h4><p>我们知道计算机的cpu在执行指令的时候，是离不开往内存里读数据和写数据的，但是我们也知道往内存里读写数据的速度，相比于CPU执行指令的速度是要慢很多的，于是在CPU和内存之间就有了高速缓存Cache。也就是说为了避免读写内内存降低指令执行的速度和CPU的效率，当程序在运行时，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 </p><p><img src="/2017/11/13/JAVA并发编程之Volatile变量应用详解/内存模型.PNG" alt="内存模型" title="内存模型"></p><h4 id="（2）-可见性"><a href="#（2）-可见性" class="headerlink" title="（2）    可见性"></a>（2）    可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。假如上面的X具有可见性，也就不会具有上面的问题。  </p><h4 id="（3）-原子性"><a href="#（3）-原子性" class="headerlink" title="（3）    原子性"></a>（3）    原子性</h4><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><h4 id="（4）-有序性"><a href="#（4）-有序性" class="headerlink" title="（4）    有序性"></a>（4）    有序性</h4><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><h3 id="三、-细说Volatile"><a href="#三、-细说Volatile" class="headerlink" title="三、 细说Volatile"></a>三、 细说Volatile</h3><p>明白了上述的概念后，可以为volatile修饰重新下一个定义：Volatile 变量具有可见性特性，但是不具备原子特性 ，volatile禁止进行指令重排序。一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，也就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，而不是读取原来Cache中的值。 下面具体的来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>(实际上，上述的这种结构也是我们在编程的过程中常用到的一种结构），由一个状态标志值控制一段程序是否执行，当flag未用volatile修饰时，线程1中可能读到一个值为true的flag到自己的Cache中，每次执行循环判断时，都从Cache中读flag 的值进行判断，导致循环永远不会结束，即使线程2执行后将flag改为false,写回内存中，但是线程1不从内存读值，便始终读到的flag都是true，导致无法结束循环，但是如果flag用volatile修饰后，只要线程2修改了flag 的值，并重新写回内存后，线程1在执行时，cache中的flag值将是无效的，需要强制从内存中读值，也就能读到改变后的flag的值，循环也将能够退出。<br>    上述的定义中还值得注的一点是volatile不具有原子性，我们再来看另一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个由volatile修饰的变量由多个线程共享</span></span><br><span class="line">Public <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//做10次循环，每次循环创建一个线程，对x做100次自加运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个线程，对x做100次自加运算</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">        Thread.yield();</span><br><span class="line"><span class="comment">//显示x的值</span></span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终的运算结果是：<br><img src="/2017/11/13/JAVA并发编程之Volatile变量应用详解/输出结果.PNG" alt="结果" title=" "></p><p>实际上，每次运行的结果都可能不同，按照前面的分析，加了volatile修饰后即使是多个线程之间，每次对x的值的更改，其他的线程也会马上接收到，那10次循环，每次循环的一个线程对x执行100次自加运算，那结果应该为1000才对，那为什么每次执行的结果还不相同呢？因为volatile不具有原子性，其实此处的自增运算X++,不是一个原子操作，涉及到一次都读操作，和一次写操作，假设一个线程读完x的值，完成一次自加1后，还未执行写操作，就立马执行另一个线程，此线程执行读操作，从内存读值，由于之前的线程并未执行写操作，还未将增加的值写入内存，第二个线程自然也就只读到原来的值，他执行自增操作后，将值写入内存，线程1读操作已经完成，在执行写操作，再将自己自增完的值写入内存，实际上两个线程就只对x的值增加了1，这就和我们的设想有偏差了，也就导致了每次的结果是不确定的，这也就很好的说明了volatie不具有原子性。  </p><p> 这也提醒了我们在使用volatile修饰的变量时，虽然使得变量具有了可见性，但是并不具有原子性，也就是说volatile的安全使用是有限制的。如果同时需要保证可见性和原子性，那就需要使用synchronized关键字，关于synchronized关键字，这里不做多说，但是我们需要知道synchronized是一个内置锁的加锁机制，当一段临界区代码有了这个加锁机制之后，多个线程中某一时刻只允许一个线程在执行这段这段代码，那既然有了synchronized ，为什么还需要Volatile，网上有一个比较好的回答，volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种synchronized关键字更轻量级的同步机制。volatile 操作不会像锁一样造成阻塞，某些时刻，volatile变量同步机制的性能要高于synchronized，使用上也比使用相应的锁简单得多。</p><h3 id="四、正确使用-volatile-变量"><a href="#四、正确使用-volatile-变量" class="headerlink" title="四、正确使用 volatile 变量"></a>四、正确使用 volatile 变量</h3><h4 id="（1）状态标记量"><a href="#（1）状态标记量" class="headerlink" title="（1）状态标记量"></a>（1）状态标记量</h4><p>  也就是举的第一个代码的例子，将 volatile 变量作为状态标志布尔变量使用，用于指示发生了一个重要的一次性事件。<br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><h4 id="（2）独立观察"><a href="#（2）独立观察" class="headerlink" title="（2）独立观察"></a>（2）独立观察</h4><p>定期 “发布” 观察结果供程序内部使用，就是说假如一个线程一直在接收一个一直在改变的数据写到volatile变量中，另外一个线程隔一段时间将会读取这个volatile变量进行一些操作。</p><p>如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。<br>好像我自己当前能理解、用到的也就这两种，其实，我对上面两种情况的理解也就是多个线程对一个共享变量的操作是原子操作的情况下，可以使用volatile变量，这样不会引起线程同步安全问题的，但使得维护线程同步安全的代价降到很低。无需用到synchronized。</p><h3 id="五、-volatile的原理和实现机制"><a href="#五、-volatile的原理和实现机制" class="headerlink" title="五、 volatile的原理和实现机制"></a>五、 volatile的原理和实现机制</h3><p>通过网上查阅和书籍查阅，简单理解了volatile的原理和实现机制，这是网上对原理解析的一段话：<br>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。    —— <a href="" target="_blank">  《深入理解Java虚拟机》</a></p><p>lock前缀指令实际上会提供3个功能：  </p><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。  </li></ul><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>关于volatile变量，我自己通过各方面的资料查阅，理解也就差不多如上，总结来说，volatilei变量是一种比 synchronized关键字更轻量级的同步机制。volatile 操作不会像锁一样造成阻塞，volatile修饰的变量具有可见性，但是不具有原子性，volatile禁止进行指令重排序，严格遵循volatile的使用条件的话，某些情况下可以使用 volatile 代替 synchronized 来简化代码。</p><p>资料参考：<br>［1］海子.Java并发编程volatile关键字解析[J/OL]   <a href="http://www.importnew.com/18126.html" title="　" target="_blank" rel="noopener">http://www.importnew.com/18126.html</a><br>［2］周志明．深入理解Java虚拟机 [M]．第1版.机械工业出版社，2011年6月</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;———关于多线程编程，实在有太多的惊喜在等着你去发现，一步一脚印&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA　多线程并发" scheme="http://yoursite.com/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
