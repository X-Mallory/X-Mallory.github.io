<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>X-Mallory</title>
  
  <subtitle>Goals determine what you are going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-04T16:41:26.171Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小小苏</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从比特币开始学习区块链</title>
    <link href="http://yoursite.com/2018/06/03/%E4%BB%8E%E6%AF%94%E7%89%B9%E5%B8%81%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://yoursite.com/2018/06/03/从比特币开始学习区块链/</id>
    <published>2018-06-03T15:11:44.000Z</published>
    <updated>2018-06-04T16:41:26.171Z</updated>
    
    <content type="html"><![CDATA[<hr><p>区块链作为当前一个比较热门的新概念，一直不是很懂，但其中涉及到密码学安全的应用，遂网上查找资料，结合区块链技术在比特币上的应用，将自己的理解分享出来，也算是对自己的学习做一记录，如有错误，请多指点！</p><hr><a id="more"></a><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>在说区块链之前，首先来说一下比特币，不同的人可能对于比特币会有不同的理解，借用网上一位网友比较简单直白的解读：</p><blockquote><ul><li>比特币是一种基于分布式网络的数字货币。</li><li>比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。</li></ul></blockquote><p>在比特币的世界，没有属于个人的账户的概念，只有比特币钱包，所谓的比特币钱包，其实可以简单理解为一个<strong>公钥</strong>。由于电子计算机内的任何东西都是可以零成本复制的，所以就必须采用<strong>非对称密码技术</strong>解决这个问题。<br>简单点说，一个钱包的含义就是“任何人都可以放钱进去，但只有你自己可以拿钱出来”，你之所以比别人多一个拿钱出来花的权力，是因为你持有和钱包公钥对应的私钥！请务必记住，私钥就是你打开钱包花钱的钥匙，一旦被别人窃取，钱也就是别人的了，一旦丢失或者销毁，钱包里的钱也就相当于跟着销毁了，就好像现实中你把纸钞撕毁焚烧了一样。  </p><p>在比特币世界，所有能花费的钱被统一表示成UTXO(即Unspent Transaction Output)，该UTXO和一个钱包地址关联，你要想知道你还有多少钱可以花，你只能遍历你所拥有的钱包，然后把和该钱包关联的UTXO累加在一起，结果便是你的“账户余额。所有的这一切信息，全部分布式存储在已经达成全网共识的区块链里。<br>UTXO只有唯一的两个来源： </p><blockquote><ul><li>被人转给自己</li><li>自己挖矿所得</li></ul></blockquote><p>比特币交易就是从一个比特币钱包向另一个中转账，每笔交易都有数字签名来保证安全。一个交易一旦发生那么就是对所有人都公开的，当 Alice 想要给 Bob 转币的时候，就用私钥来签署一段信息，其中包括输入，数目和输出这三项前面已经提过的内容。这样，信息广播到比特币网络上，矿工就可以验证这次交易，把交易加入区块链中了,一旦加入区块链成功，也就表示此次交易成功，也表示此次的交易被加入到了分布式的账本中。  </p><p><img src="/2018/06/03/从比特币开始学习区块链/比特币交易.PNG" alt="比特币交易" title="比特币交易"></p><blockquote><ul><li>输入：这里面记录了最初 Alice  拥有的这些币是从哪个地址转给她的，假设她是从她的朋友 Eve 那里得到的币。</li><li>数目：这个就是 Alice 到底给 Bob 转了多少个比特币。</li><li>输出：Bob 的比特币地址。</li></ul></blockquote><h3 id="比特币的运行原理"><a href="#比特币的运行原理" class="headerlink" title="比特币的运行原理"></a>比特币的运行原理</h3><p>正如我们认识的银行那样，在银行系统的数据库里记录着跟我们身份id对应的财产，我们暂且把他叫做账本，如张三的卡10月1日转入1w, 余额10w。<br>比特币系统也同样有这样的账本，不同银行由单一的组织负责记录,比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从1万改为1百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。</p><h3 id="一个公共的分布式总帐—-区块链"><a href="#一个公共的分布式总帐—-区块链" class="headerlink" title="一个公共的分布式总帐—-区块链"></a>一个公共的分布式总帐—-区块链</h3><p>切入主题,区块链技术,我们首先考虑下面两种情况:<br>情况一:</p><blockquote><p> 想象有一个100台的分布式数据库集群，现在的情况是这100个节点实际上的拥有者是一个机构，并且所有节点处在该机构的内网当中，所以这个机构想让这100个数据库节点干嘛就干嘛，换句话说这100个节点之间是处于一个可信任的环境，并且受控于一个实体，这个实体具有绝对仲裁分配权。</p></blockquote><p>情况二:</p><blockquote><p>想象这100个节点分别归不同的人所有，且每个人的节点数据都是一样的，即完全冗余，并且所有的节点是处在广域网当中，换句话说就是这100个节点之间是不信任的，且不存在一个实体，它拥有绝对仲裁权。</p></blockquote><p>现在考虑第二种情况的话，采用什么样的算法（共识模型）能够提供一个可信任的环境，使得：</p><ul><li>每个节点交换数据过程不被篡改；交换历史记录不可被篡改；</li><li>每个节点的数据会同步到最新数据，且承认经过共识的最新数据；</li><li>基于少数服从多数的原则，整体节点维护的数据本身客观反映了交换历史。</li></ul><p><strong>区块链本质上就是要解决以上第二种情况的一种技术方案，更确切的说应该叫分布式的冗余的链式总帐本方案。</strong>   </p><p>要解决第二种情况的问题，那么区块链技术应该要具有这样的一些特性：</p><blockquote><ul><li>包含一个分布式数据库</li><li>区块链只对添加有效，对其他操作无效</li><li>分布式数据库作为区块链的物理载体，所有核心节点都应包含该条区块链数据的全副本</li><li>共识过程（consensus progress）是演化稳定的，所谓共识过程，指的是面对不同节点的矛盾数据，不会导致崩溃，关于矛盾数据，不同节点间最终应该能达成共识</li><li>记账节点要求拜占庭将军问题可解</li><li>基于非对称加密的公私钥验证</li></ul></blockquote><p>我们继续回到比特币上，我们继续看，结合前文说的比特币的运行原理，其中说到比特币系统需要维护一个由所有节点共同维护的账本，它是如何维护的呢，这就用到了区块链技术：  </p><h3 id="比特币区块链记账方法"><a href="#比特币区块链记账方法" class="headerlink" title="比特币区块链记账方法"></a>比特币区块链记账方法</h3><p>假设有一个账页序号为0的账页交易记录如下:</p><table><thead><tr><th style="text-align:center">账号</th><th style="text-align:center">入账</th><th style="text-align:center">出账</th><th style="text-align:center">余额</th><th style="text-align:center">备注说明</th></tr></thead><tbody><tr><td style="text-align:center">张三</td><td style="text-align:center">1600</td><td style="text-align:center"></td><td style="text-align:center">1600</td><td style="text-align:center">XXX转入</td></tr><tr><td style="text-align:center">李四</td><td style="text-align:center"></td><td style="text-align:center">600</td><td style="text-align:center">1200</td><td style="text-align:center">转给XXX</td></tr></tbody></table><p>记账时间为：2017-10-22 10:22:02</p><p>区块链记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：  </p><p><em>Hash(序号0、记账时间、交易记录) = 787635ACD</em></p><p>账页信息和Hash值组合在一起就构成了第一个区块。</p><p><strong>比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟</strong></p><p>在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即：</p><p><em>Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD</em>  </p><p>这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。<br>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。</p><h3 id="记账与挖矿"><a href="#记账与挖矿" class="headerlink" title="记账与挖矿"></a>记账与挖矿</h3><p>上面说到记账是把交易记录、交易时间、账本序号、上一个Hash值等信息计算Hash打包的过程。我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为“挖矿”。</p><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是12.5比特币，每个比特币是4万人民币以上），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解这个问题，规则如下：</p><ul><li>一段时间内（10分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li><li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li><li>其他节点复制记账结果<br>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</li><li>收集广播中还没有被记录账本的原始交易信息</li><li>检查每个交易信息中付款地址有没有足够的余额</li><li>验证交易是否有正确的签名</li><li>把验证通过的交易信息进行打包记录</li><li>添加一个奖励交易：给自己的地址增加12.5比特币<br>如果节点争夺记账权成功的话，就可以得到12.5比特币的奖励。 </li></ul><h3 id="关于工作量证明"><a href="#关于工作量证明" class="headerlink" title="关于工作量证明"></a>关于工作量证明</h3><p>每次记账的时候会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash。<br>如果仅仅是这样，显然每个人都可以很轻松的完成记账。<br>为了保证10分钟左右只有一个人可以记账，就必须要提高记账的难度，使得Hash的结果必须以若干个0开头。同是为了满足这个条件，在进行Hash时引入一个随机数变量。</p><blockquote><p>Hash(上一个Hash值，交易记录集) = 456635BCD</p></blockquote><blockquote><p>Hash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD</p></blockquote><p>我们知道改变Hash的原始信息的任何一部分，Hash值也会随之不断的变化，因此在运算Hash时，不断的改变随机数的值，总可以找的一个随机数使的Hash的结果以若干个0开头，率先找到随机数的节点就获得此次记账的唯一记账权。  </p><p><img src="/2018/06/03/从比特币开始学习区块链/Hash.png" alt="挖矿" title="挖矿"></p><p> 在节点成功找到满足的Hash值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。<br>如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。<br>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p><h5 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h5><p>拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题就此形成。<br>区块链中，可以将这里的叛徒看成是一台有故障不断向其他节点发出错误信息的计算机，或是一台计算机，为谋取暴利，做了一份假的账本，不断向其他节点发送。  </p><h5 id="公钥密码体制-public-key-cryptography"><a href="#公钥密码体制-public-key-cryptography" class="headerlink" title="公钥密码体制(public-key cryptography)"></a>公钥密码体制(public-key cryptography)</h5><p>公钥密码体制分为三个部分，公钥、私钥、加密解密算法，它的加密解密过程如下：<br>加密：通过加密算法和公钥对内容(或者说明文)进行加密，得到密文。加密过程需要用到公钥。<br>解密：通过解密算法和私钥对密文进行解密，得到明文。解密过程需要用到解密算法和私钥。注意，由公钥加密的内容，只能由私钥进行解密，也就是说，由公钥加密的内容，如果不知道私钥，是无法解密的。<br>公钥密码体制的公钥和算法都是公开的(这是为什么叫公钥密码体制的原因)，私钥是保密的。大家都以使用公钥进行加密，但是只有私钥的持有者才能解密。在实际的使用中，有需要的人会生成一对公钥和私钥，把公钥发布出去给别人使用，自己保留私钥。</p><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><p>哈希函数在密码学中被用来做消息摘要，一个消息摘唯一对应一个消息或文本，并且这个消息摘要的长度通常是固定的，原始消息或文本中任何微小的改变都将导致消息摘要值的改变，通过消息摘要，可以验证消息的完整性。<br>哈希函数：Hash(原始信息) = 摘要信息<br>原始信息可以是任意的信息, hash之后会得到一个简短的摘要信息<br>哈希函数有几个特点:</p><ul><li>同样的原始信息用同一个哈希函数总能得到相同的摘要信息</li><li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li><li>从摘要信息无法逆向推算出原始信息<br>举例说明：<br>Hash(张三借给李四100万，利息1%，1年后还本息 …..) = AC4635D34DEF<br>账本上记录了AC4635D34DEF这样一条记录。<br>可以看出哈希函数有4个作用：<blockquote><ul><li>简化信息：很好理解，哈希后的信息变短了。</li><li>标识信息：可以使用AC4635D34DEF来标识原始信息，摘要信息也称为原始信息的id。</li><li>隐匿信息：账本是AC4635D34DEF这样一条记录，原始信息被隐匿。</li><li>验证信息：假如李四在还款时欺骗说，张三只借给李四10万，双方可以用AC4635D34DEF来验证信息 </li></ul></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;区块链作为当前一个比较热门的新概念，一直不是很懂，但其中涉及到密码学安全的应用，遂网上查找资料，结合区块链技术在比特币上的应用，将自己的理解分享出来，也算是对自己的学习做一记录，如有错误，请多指点！&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="密码学应用" scheme="http://yoursite.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    
    
      <category term="比特币" scheme="http://yoursite.com/tags/%E6%AF%94%E7%89%B9%E5%B8%81/"/>
    
      <category term="区块链" scheme="http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>心有猛虎 细嗅蔷薇</title>
    <link href="http://yoursite.com/2018/05/10/%E5%BF%83%E6%9C%89%E7%8C%9B%E8%99%8E-%E7%BB%86%E5%97%85%E8%94%B7%E8%96%87/"/>
    <id>http://yoursite.com/2018/05/10/心有猛虎-细嗅蔷薇/</id>
    <published>2018-05-10T04:08:53.000Z</published>
    <updated>2018-05-10T13:05:41.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="In-me-the-tiger-sniffs-the-rose"><a href="#In-me-the-tiger-sniffs-the-rose" class="headerlink" title="In me the tiger sniffs the rose"></a><center>In me the tiger sniffs the rose</center></h2><p align="right">————心有猛虎 细嗅蔷薇</p><p><img src="/2018/05/10/心有猛虎-细嗅蔷薇/树叶.jpg" alt="In me the tiger sniffs the rose" title="细嗅蔷薇"></p><p>每个人的内心深处都穴居着一只猛虎，只是在虎穴之外仍有蔷薇丛生。<br><a id="more"></a></p><p>我将于茫茫人海中访我唯一灵魂之伴侣；<br>得之，我幸；不得，我命。  </p><p align="right">———  徐志摩 </p>   <p>笑，全世界便与你同声笑，哭，你便独自哭。<br>因为爱过，所以慈悲；因为懂得，所以宽容。</p><p align="right">———张爱玲</p>   <p>爱在左，情在右，<br>走在生命路的两旁，<br>随时撒种，随时开花。</p><p align="right">———冰心 </p>   <p>我行过许多地方的桥，<br>看过许多次数的云，<br>喝过许多种类的酒，<br>却只爱过一个正当最好年龄的人。</p><p align="right">———沈从文</p>  <p>撑着油纸伞，独自彷徨在悠长、<br>悠长又寂寥的雨巷我希望逢着一个，<br>丁香一样地结着愁<br>的姑娘 。</p><p align="right">———戴舒望</p>   <p>人生不过如此，且行且珍惜。<br>自己永远是自己的主角，<br>不要总在别人的戏剧里充当着配角。<br>人生在世，还不是有时笑笑人家，<br>有时给人家笑笑。</p><p align="right">———林语堂 </p>   <p>多年前踏上火车时，我还没有意识到，<br>从此我的故乡没有春夏，只有秋冬。<br>热闹是他们的，我什么也没有。</p><p align="right">———朱自清 </p>   <p>我知道你要来，所以我等。</p><p align="right">———沈从文 </p>   ]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;In-me-the-tiger-sniffs-the-rose&quot;&gt;&lt;a href=&quot;#In-me-the-tiger-sniffs-the-rose&quot; class=&quot;headerlink&quot; title=&quot;In me the tiger sniffs the rose&quot;&gt;&lt;/a&gt;&lt;center&gt;In me the tiger sniffs the rose&lt;/center&gt;&lt;/h2&gt;&lt;p align=&quot;right&quot;&gt;————心有猛虎 细嗅蔷薇&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/2018/05/10/心有猛虎-细嗅蔷薇/树叶.jpg&quot; alt=&quot;In me the tiger sniffs the rose&quot; title=&quot;细嗅蔷薇&quot;&gt;&lt;/p&gt;
&lt;p&gt;每个人的内心深处都穴居着一只猛虎，只是在虎穴之外仍有蔷薇丛生。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="谈文识字" scheme="http://yoursite.com/categories/%E8%B0%88%E6%96%87%E8%AF%86%E5%AD%97/"/>
    
    
      <category term="诗词" scheme="http://yoursite.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
      <category term="散文" scheme="http://yoursite.com/tags/%E6%95%A3%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>共勉</title>
    <link href="http://yoursite.com/2018/05/03/%E5%85%B1%E5%8B%89/"/>
    <id>http://yoursite.com/2018/05/03/共勉/</id>
    <published>2018-05-03T11:13:36.000Z</published>
    <updated>2018-05-04T10:47:55.152Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/03/共勉/风筝.jpg" alt="诗和远方" title="有诗也有远方"><br><a id="more"></a></p><h5 id="我不去想是否能够成功"><a href="#我不去想是否能够成功" class="headerlink" title="我不去想是否能够成功 "></a><center>我不去想是否能够成功 </center></h5><h5 id="既然选择了远方"><a href="#既然选择了远方" class="headerlink" title="既然选择了远方 "></a><center>既然选择了远方 </center></h5><h5 id="便只顾风雨兼程"><a href="#便只顾风雨兼程" class="headerlink" title="便只顾风雨兼程   "></a><center>便只顾风雨兼程   </center></h5><h5 id="我不去想能否赢得爱情"><a href="#我不去想能否赢得爱情" class="headerlink" title="我不去想能否赢得爱情 "></a><center>我不去想能否赢得爱情 </center></h5><h5 id="既然钟情于玫瑰"><a href="#既然钟情于玫瑰" class="headerlink" title="既然钟情于玫瑰 "></a><center>既然钟情于玫瑰 </center></h5><h5 id="就勇敢地吐露真诚"><a href="#就勇敢地吐露真诚" class="headerlink" title="就勇敢地吐露真诚   "></a><center>就勇敢地吐露真诚   </center></h5><h5 id="我不去想身后-会不会袭来寒风冷雨"><a href="#我不去想身后-会不会袭来寒风冷雨" class="headerlink" title="我不去想身后 会不会袭来寒风冷雨 "></a><center>我不去想身后 会不会袭来寒风冷雨 </center></h5><h5 id="既然目标是地平线"><a href="#既然目标是地平线" class="headerlink" title="既然目标是地平线 "></a><center>既然目标是地平线 </center></h5><h5 id="留给世界的只能是背影"><a href="#留给世界的只能是背影" class="headerlink" title="留给世界的只能是背影  "></a><center>留给世界的只能是背影  </center></h5><h5 id="我不去想未来是平坦还是泥泞"><a href="#我不去想未来是平坦还是泥泞" class="headerlink" title="我不去想未来是平坦还是泥泞  "></a><center>我不去想未来是平坦还是泥泞  </center></h5><h5 id="只要热爱生命"><a href="#只要热爱生命" class="headerlink" title="只要热爱生命 "></a><center>只要热爱生命 </center></h5><h5 id="一切，都在意料之中"><a href="#一切，都在意料之中" class="headerlink" title="一切，都在意料之中  "></a><center>一切，都在意料之中  </center></h5><p align="right"><br>–至今，我仍然记得这是高中班主任很喜欢的一首诗，共勉 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/03/共勉/风筝.jpg&quot; alt=&quot;诗和远方&quot; title=&quot;有诗也有远方&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="谈文识字" scheme="http://yoursite.com/categories/%E8%B0%88%E6%96%87%E8%AF%86%E5%AD%97/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="诗词" scheme="http://yoursite.com/tags/%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程之Volatile变量应用详解</title>
    <link href="http://yoursite.com/2017/11/13/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BVolatile%E5%8F%98%E9%87%8F%E5%BA%94%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/11/13/JAVA并发编程之Volatile变量应用详解/</id>
    <published>2017-11-13T11:21:18.000Z</published>
    <updated>2018-05-04T12:09:15.260Z</updated>
    
    <content type="html"><![CDATA[<p></p><p align="right">———关于多线程编程，实在有太多的惊喜在等着你去发现，一步一脚印</p><br><a id="more"></a><p></p><h3 id="一、-Volatile关键字概述"><a href="#一、-Volatile关键字概述" class="headerlink" title="一、 Volatile关键字概述"></a>一、 Volatile关键字概述</h3><p>首先明确一点，Volatile是JAVA（其他语言如C++也相似）中的一个关键字，一种书写于成员变量之前的修饰符，如static，public一样，他书写于某种类型的变量之前，表征定义的变量具有相关的特性。之所以说明这一点，是为了避免对标题“Volatile变量”的歧义理解，它不是一种具体的变量的类型，而是对某一种具体变量的修饰。如 volatile int a。明确这一点后，先大致说明一下这个volatile修饰具有怎样的含义：Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。为了深刻理解上面关于volatile的说明，接下来做具体的说明。</p><h3 id="二、-和volatile相关的几个基本概念"><a href="#二、-和volatile相关的几个基本概念" class="headerlink" title="二、 和volatile相关的几个基本概念"></a>二、 和volatile相关的几个基本概念</h3><p>为了更好的理解volatile，首先先说明几个相关的几个基本概念：</p><h4 id="（1）-内存模型（JAVA内存模型）"><a href="#（1）-内存模型（JAVA内存模型）" class="headerlink" title="（1）    内存模型（JAVA内存模型）"></a>（1）    内存模型（JAVA内存模型）</h4><p>我们知道计算机的cpu在执行指令的时候，是离不开往内存里读数据和写数据的，但是我们也知道往内存里读写数据的速度，相比于CPU执行指令的速度是要慢很多的，于是在CPU和内存之间就有了高速缓存Cache。也就是说为了避免读写内内存降低指令执行的速度和CPU的效率，当程序在运行时，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 </p><p><img src="/2017/11/13/JAVA并发编程之Volatile变量应用详解/内存模型.PNG" alt="内存模型" title="内存模型"></p><h4 id="（2）-可见性"><a href="#（2）-可见性" class="headerlink" title="（2）    可见性"></a>（2）    可见性</h4><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。假如上面的X具有可见性，也就不会具有上面的问题。  </p><h4 id="（3）-原子性"><a href="#（3）-原子性" class="headerlink" title="（3）    原子性"></a>（3）    原子性</h4><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p><h4 id="（4）-有序性"><a href="#（4）-有序性" class="headerlink" title="（4）    有序性"></a>（4）    有序性</h4><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><h3 id="三、-细说Volatile"><a href="#三、-细说Volatile" class="headerlink" title="三、 细说Volatile"></a>三、 细说Volatile</h3><p>明白了上述的概念后，可以为volatile修饰重新下一个定义：Volatile 变量具有可见性特性，但是不具备原子特性 ，volatile禁止进行指令重排序。一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的，也就是说当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值，而不是读取原来Cache中的值。 下面具体的来看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>(实际上，上述的这种结构也是我们在编程的过程中常用到的一种结构），由一个状态标志值控制一段程序是否执行，当flag未用volatile修饰时，线程1中可能读到一个值为true的flag到自己的Cache中，每次执行循环判断时，都从Cache中读flag 的值进行判断，导致循环永远不会结束，即使线程2执行后将flag改为false,写回内存中，但是线程1不从内存读值，便始终读到的flag都是true，导致无法结束循环，但是如果flag用volatile修饰后，只要线程2修改了flag 的值，并重新写回内存后，线程1在执行时，cache中的flag值将是无效的，需要强制从内存中读值，也就能读到改变后的flag的值，循环也将能够退出。<br>    上述的定义中还值得注的一点是volatile不具有原子性，我们再来看另一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volatile</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个由volatile修饰的变量由多个线程共享</span></span><br><span class="line">Public <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//做10次循环，每次循环创建一个线程，对x做100次自加运算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//创建一个线程，对x做100次自加运算</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">        Thread.yield();</span><br><span class="line"><span class="comment">//显示x的值</span></span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终的运算结果是：<br><img src="/2017/11/13/JAVA并发编程之Volatile变量应用详解/输出结果.PNG" alt="结果" title=" "></p><p>实际上，每次运行的结果都可能不同，按照前面的分析，加了volatile修饰后即使是多个线程之间，每次对x的值的更改，其他的线程也会马上接收到，那10次循环，每次循环的一个线程对x执行100次自加运算，那结果应该为1000才对，那为什么每次执行的结果还不相同呢？因为volatile不具有原子性，其实此处的自增运算X++,不是一个原子操作，涉及到一次都读操作，和一次写操作，假设一个线程读完x的值，完成一次自加1后，还未执行写操作，就立马执行另一个线程，此线程执行读操作，从内存读值，由于之前的线程并未执行写操作，还未将增加的值写入内存，第二个线程自然也就只读到原来的值，他执行自增操作后，将值写入内存，线程1读操作已经完成，在执行写操作，再将自己自增完的值写入内存，实际上两个线程就只对x的值增加了1，这就和我们的设想有偏差了，也就导致了每次的结果是不确定的，这也就很好的说明了volatie不具有原子性。  </p><p> 这也提醒了我们在使用volatile修饰的变量时，虽然使得变量具有了可见性，但是并不具有原子性，也就是说volatile的安全使用是有限制的。如果同时需要保证可见性和原子性，那就需要使用synchronized关键字，关于synchronized关键字，这里不做多说，但是我们需要知道synchronized是一个内置锁的加锁机制，当一段临界区代码有了这个加锁机制之后，多个线程中某一时刻只允许一个线程在执行这段这段代码，那既然有了synchronized ，为什么还需要Volatile，网上有一个比较好的回答，volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种synchronized关键字更轻量级的同步机制。volatile 操作不会像锁一样造成阻塞，某些时刻，volatile变量同步机制的性能要高于synchronized，使用上也比使用相应的锁简单得多。</p><h3 id="四、正确使用-volatile-变量"><a href="#四、正确使用-volatile-变量" class="headerlink" title="四、正确使用 volatile 变量"></a>四、正确使用 volatile 变量</h3><h4 id="（1）状态标记量"><a href="#（1）状态标记量" class="headerlink" title="（1）状态标记量"></a>（1）状态标记量</h4><p>  也就是举的第一个代码的例子，将 volatile 变量作为状态标志布尔变量使用，用于指示发生了一个重要的一次性事件。<br>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><h4 id="（2）独立观察"><a href="#（2）独立观察" class="headerlink" title="（2）独立观察"></a>（2）独立观察</h4><p>定期 “发布” 观察结果供程序内部使用，就是说假如一个线程一直在接收一个一直在改变的数据写到volatile变量中，另外一个线程隔一段时间将会读取这个volatile变量进行一些操作。</p><p>如：假设有一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。<br>好像我自己当前能理解、用到的也就这两种，其实，我对上面两种情况的理解也就是多个线程对一个共享变量的操作是原子操作的情况下，可以使用volatile变量，这样不会引起线程同步安全问题的，但使得维护线程同步安全的代价降到很低。无需用到synchronized。</p><h3 id="五、-volatile的原理和实现机制"><a href="#五、-volatile的原理和实现机制" class="headerlink" title="五、 volatile的原理和实现机制"></a>五、 volatile的原理和实现机制</h3><p>通过网上查阅和书籍查阅，简单理解了volatile的原理和实现机制，这是网上对原理解析的一段话：<br>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。    —— <a href="" target="_blank">  《深入理解Java虚拟机》</a></p><p>lock前缀指令实际上会提供3个功能：  </p><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。  </li></ul><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>关于volatile变量，我自己通过各方面的资料查阅，理解也就差不多如上，总结来说，volatilei变量是一种比 synchronized关键字更轻量级的同步机制。volatile 操作不会像锁一样造成阻塞，volatile修饰的变量具有可见性，但是不具有原子性，volatile禁止进行指令重排序，严格遵循volatile的使用条件的话，某些情况下可以使用 volatile 代替 synchronized 来简化代码。</p><p>资料参考：<br>［1］海子.Java并发编程volatile关键字解析[J/OL]   <a href="http://www.importnew.com/18126.html" title="　" target="_blank" rel="noopener">http://www.importnew.com/18126.html</a><br>［2］周志明．深入理解Java虚拟机 [M]．第1版.机械工业出版社，2011年6月</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;p align=&quot;right&quot;&gt;———关于多线程编程，实在有太多的惊喜在等着你去发现，一步一脚印&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="JAVA　多线程并发" scheme="http://yoursite.com/tags/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
